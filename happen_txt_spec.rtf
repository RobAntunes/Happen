{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;\f1\fswiss\fcharset0 Helvetica;\f2\fswiss\fcharset0 ArialMT;
\f3\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red21\green22\blue24;\red40\green84\blue210;
\red87\green91\blue100;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c10980\c11373\c12157;\cssrgb\c20392\c42745\c85882;
\cssrgb\c41569\c43137\c46667;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs14 \cf2 Happen\
7/7/25, 07:52\

\f1\fs96\fsmilli48061 \cf3 Happen\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 1 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Welcome\

\fs25\fsmilli12816 Welcome to Happen, where we believe in the power of simplicity!\
We're excited you're here to explore a framework that turns conventional\
wisdom on its head. Instead of drowning you in abstractions and boilerplate,\
Happen gives you just two fundamental building blocks\'97Nodes and Events\'97\
that combine to create systems of surprising power and flexibility. Whether\
you're building a straightforward automation pipeline or an intricate multi-\
agent ecosystem, you'll find that Happen's minimalist approach makes\
complex problems suddenly manageable.\
Our philosophy is simple: the most elegant solutions emerge not from adding\
complexity, but from discovering the right minimal abstractions that let the\
magic happen naturally. As you dive into these docs, you'll see how a handful\
of simple concepts can unlock an entire universe of possibilities. So take a\
deep breath, let go of framework complexity, and welcome to a world where\
less truly is more.\

\fs38\fsmilli19224 Quick Links\

\fs25\fsmilli12816 \cf4 Basics\

\fs22\fsmilli11214 \cf5 Learn\

\fs25\fsmilli12816 \cf4 Getting Started\

\fs22\fsmilli11214 \cf3 Dive right in\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 2 of 234Happen\
7/7/25, 07:52\

\f1\fs76\fsmilli38449 \cf3 Getting Started\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 3 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 What is Happen?\

\fs25\fsmilli12816 Happen is a framework for building agent-based systems founded on a\
philosophy of simplicity. Unlike conventional frameworks that burden\
developers with complex abstractions, Happen provides just two fundamental\
building blocks that can be composed to create systems ranging from simple\
pipelines to complex, adaptive multi-agent ecosystems.\

\fs38\fsmilli19224 Core Philosophy\

\fs25\fsmilli12816 At its core, Happen distills agent-based systems down to their essence,\
recognizing that true power emerges from simplicity rather than complexity.\
The framework's philosophy embraces several key principles:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Radical Simplicity: Only include what's absolutely essential; solve specific\
needs with specialized nodes rather than general framework features\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Pure Causality: Everything in a Happen system happens because of\
something else, creating natural causal chains\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Decentralized Intelligence: Smart systems emerge from simple nodes\
making local decisions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Composable Simplicity: Complex behavior emerges from composing\
simple, understandable parts\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Emergence Over Prescription: Let patterns emerge naturally rather than\
forcing specific structural approaches\
This minimalist approach creates a framework that is both accessible to\
newcomers and powerful enough for experts, allowing developers to focus on\
solving domain problems rather than battling framework complexities.\

\fs38\fsmilli19224 The Foundation: Nodes and Events\

\fs25\fsmilli12816 At its foundation lie just two primitives:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 4 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 1. \cf3 Nodes - Independent, autonomous components that process and respond\
to information\
\cf5 2. \cf3 Events - Structured messages that transport data and intentions between\
Nodes\
These two simple concepts combine to create systems of surprising power\
and flexibility. Nodes act as the primary actors in a Happen system -\
independent, autonomous components that can receive and process events,\
maintain internal state, and emit new events. Events are structured messages\
that flow between nodes, representing meaningful occurrences in the domain\
rather than simple function calls.\

\fs38\fsmilli19224 Pure Causality: The Secret to Happen's Power\

\fs25\fsmilli12816 The most distinctive aspect of Happen is its embrace of pure causality as its\
organizing principle. This approach eliminates entire categories of complexity\
found in other systems.\
In Happen:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Events can only be created when their prerequisites exist\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Every event contains references to its causal predecessors\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Each event has a unique identifier that gets referenced by its dependents\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 These references form a complete causal web that defines system\
behavior\
This means that knowledge about the system is encoded directly in event flow\
patterns. Nodes don't need schema definitions or formal contracts to\
understand how to interact - they simply need to observe the event flow.\
When a node receives an event, it automatically knows:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 What event caused this one\

\f2\fs38\fsmilli19224 \cf5 \'95\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 5 of 234Happen\
7/7/25, 07:52\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 What transaction or process it's part of\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Which node originated the event\
The entire history and context are embedded in the event itself.\

\fs38\fsmilli19224 Runtime Transparency: Direct Access to Your\
Environment\

\fs25\fsmilli12816 Happen embodies simplicity not only in its design but in its relationship with\
the underlying runtime environment. Unlike conventional frameworks that\
build abstraction layers over runtime capabilities, Happen takes a\
fundamentally different approach:\
Happen is simply a coordination layer for events. The runtime belongs to your\
code.\
This means:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 No framework-specific abstractions between your code and the runtime\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Direct use of runtime capabilities without performance penalties\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Immediate access to new runtime features without waiting for framework\
updates\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Seamless integration with the broader ecosystem for your runtime\

\fs38\fsmilli19224 Why Happen? The Power of Less\

\fs25\fsmilli12816 Happen's minimalist approach offers profound advantages:\
\cf5 1. \cf3 Cognitive Accessibility: The entire framework can be understood in\
minutes, eliminating the steep learning curves associated with complex\
agent frameworks\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 6 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 2. \cf3 Unbounded Flexibility: The simple primitives can be composed in\
countless ways, enabling virtually any interaction pattern\
\cf5 3. \cf3 Natural Scalability: Systems grow organically without architectural\
reimagining, scaling from tiny applications to vast distributed networks\
\cf5 4. \cf3 Inherent Resilience: The decentralized, event-driven nature creates\
natural recovery patterns and adaptation to changing conditions\
\cf5 5. \cf3 Self-Documentation: The causal web of events documents system\
behavior automatically\
Happen demonstrates that remarkable power can emerge from intentional\
simplicity. By providing just enough structure through two core concepts, it\
enables developers to create systems that are both powerful and\
comprehensible.\
As you begin building with Happen, remember that the framework's power\
comes not from complex features or abstractions, but from how its minimal\
primitives combine to create emergent behaviors. Start simple, observe how\
events flow through your system, and let the natural patterns guide your\
development.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 7 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Runtime Philosophy\

\fs25\fsmilli12816 Happen embodies simplicity not only in its design but in its relationship with\
the underlying runtime environment. Unlike conventional frameworks that\
build abstraction layers over runtime capabilities, Happen takes a\
fundamentally different approach:\
Happen is simply a coordination layer for events. The runtime belongs to your\
code.\
This approach has profound implications for how you build systems with\
Happen.\

\fs38\fsmilli19224 Direct Runtime Access\

\fs25\fsmilli12816 With Happen, there are no framework-specific abstractions standing between\
your code and the runtime:\

\fs22\fsmilli11214 // A Happen node handling file operations\
fileNode.on('save-document', async event => \{\
const \{ path, content \} = event.payload;\
try \{\
// Direct use of runtime capabilities\
// No "Happen way" to do this - just use the runtime\
await Bun.write(path, content);\
// Return success result\
return \{\
status: 'success',\
path\
\};\
\} catch (error) \{\
// Return error result\
return \{\
status: 'error',\
reason: error.message\
\};\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 8 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \}\
\});\

\fs25\fsmilli12816 This example demonstrates a crucial aspect of Happen's philosophy: the\
framework doesn't try to abstract, wrap, or "improve" the runtime's\
capabilities. Your event handlers are simply JavaScript functions with full,\
direct access to whatever runtime they're executing in.\

\fs38\fsmilli19224 The Invisible Framework\

\fs25\fsmilli12816 Happen is designed to be virtually invisible from a runtime perspective:\

\fs22\fsmilli11214 // Creating a web server node\
httpNode.on('start-server', event => \{\
const \{ port \} = event.payload;\
// Direct use of Bun's HTTP server capabilities\
const server = Bun.serve(\{\
port,\
fetch(request) \{\
// Convert HTTP requests to events\
const requestEvent = \{\
type: 'http-request',\
payload: \{\
url: request.url,\
method: request.method,\
headers: Object.fromEntries(request.headers.entries()),\
body: request.body\
\}\
\};\
// Process through Happen's event system\
const responseEvent = httpNode.processSync(requestEvent);\
// Convert response event back to HTTP\
return new Response(\
responseEvent.payload.body,\
\{\
status: responseEvent.payload.status,\
headers: responseEvent.payload.headers\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 9 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \}\
);\
\}\
\});\
// Store server instance for later management\
httpNode.server = server;\
return \{ status: 'started', port \};\
\});\

\fs25\fsmilli12816 In this example, the node creates and manages a web server using the\
runtime's native capabilities. Happen simply provides the event-based\
coordination layer, not the HTTP functionality itself.\

\fs38\fsmilli19224 "Glue with Superpowers"\

\fs25\fsmilli12816 This runtime philosophy exemplifies Happen's role as "glue with\
superpowers":\
\cf5 1. \cf3 It's Just Glue: Happen connects different pieces of functionality without\
dictating how that functionality is implemented\
\cf5 2. \cf3 Your Code, Your Runtime: Your event handlers have complete freedom to\
use the runtime however they need\
\cf5 3. \cf3 No Hidden Magic: There's no framework-specific way to access runtime\
features - you use them directly\
\cf5 4. \cf3 No Learning Curve: If you know how to use the runtime, you already know\
how to use it with Happen\

\fs38\fsmilli19224 The Benefits of Runtime Transparency\

\fs25\fsmilli12816 This direct relationship between your code and the runtime offers several key\
advantages:\

\fs32\fsmilli16020 1. Zero Overhead\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 10 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Since Happen doesn't abstract the runtime, there's no performance penalty\
for accessing runtime capabilities:\

\fs22\fsmilli11214 // No performance penalty for runtime access\
databaseNode.on('query-users', async event => \{\
const \{ filter \} = event.payload;\
// Direct database query using runtime capabilities\
// No layers of abstraction adding overhead\
const statement = db.prepare(`\
SELECT * FROM users\
WHERE name LIKE ?\
`);\
const users = statement.all(`%$\{filter\}%`);\
return \{ users \};\
\});\

\fs32\fsmilli16020 2. Full Runtime Capabilities\

\fs25\fsmilli12816 You have access to everything the runtime offers, not just what the framework\
developers thought to expose:\

\fs22\fsmilli11214 // Using advanced runtime features\
processingNode.on('process-image', async event => \{\
const \{ imagePath, options \} = event.payload;\
// Access to cutting-edge runtime features\
// as soon as they're available in the runtime\
const imageData = await Bun.file(imagePath).arrayBuffer();\
const processed = await ImageProcessor.process(imageData,\
options);\
await Bun.write(`$\{imagePath\}.processed`, processed);\
return \{ status: 'completed', outputPath:\
`$\{imagePath\}.processed` \};\
\});\

\fs32\fsmilli16020 3. Runtime Evolution\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 11 of 234Happen\
7/7/25, 07:52\

\f1\fs32\fsmilli16020 \cf3 3. Runtime Evolution\

\fs25\fsmilli12816 As the runtime evolves with new capabilities, they're immediately available\
without waiting for framework updates:\

\fs22\fsmilli11214 // Immediate access to new runtime features\
node.on('use-new-feature', event => \{\
// When the runtime adds new capabilities,\
// you can use them immediately without framework updates\
const result = Bun.newCapability(event.payload);\
return \{ result \};\
\});\

\fs32\fsmilli16020 4. Ecosystem Compatibility\

\fs25\fsmilli12816 Your Happen code works seamlessly with the broader ecosystem for your\
runtime:\

\fs22\fsmilli11214 // Seamless integration with ecosystem libraries\
analyticsNode.on('analyze-data', async event => \{\
const \{ dataset \} = event.payload;\
// Use any ecosystem library directly\
// No need for framework-specific adapters or wrappers\
const analysis = await performAnalysis(dataset);\
return \{ results: analysis \};\
\});\
// Helper function using ecosystem libraries\
async function performAnalysis(dataset) \{\
// Direct use of ecosystem libraries\
// No "Happen way" to integrate libraries\
const results = await someAnalyticsLibrary.process(dataset);\
return results;\
\}\

\fs38\fsmilli19224 Consistent Philosophy Across Environments\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 12 of 234Happen\
7/7/25, 07:52\

\f1\fs38\fsmilli19224 \cf3 Consistent Philosophy Across Environments\

\fs25\fsmilli12816 This runtime philosophy remains consistent whether you're using Bun,\
Node.js, Deno, or browsers:\

\fs22\fsmilli11214 // The same approach works across different runtimes\
function createFileNode(id) \{\
const node = createNode(id);\
// Handler implementation uses runtime-appropriate APIs\
// but the Happen code remains the same\
node.on('read-file', async event => \{\
const \{ path \} = event.payload;\
try \{\
// In Bun\
const content = await Bun.file(path).text();\
// In Node.js\
// const content = await fs.promises.readFile(path, 'utf8');\
// In Deno\
// const content = await Deno.readTextFile(path);\
// In browser\
// const response = await fetch(path);\
// const content = await response.text();\
return \{ content \};\
\} catch (error) \{\
return \{ error: error.message \};\
\}\
\});\
return node;\
\}\

\fs25\fsmilli12816 While the specific API calls differ between environments, Happen's\
relationship with the runtime remains the same: it simply provides event\
coordination while giving your code direct access to the runtime.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 13 of 234Happen\
7/7/25, 07:52\

\f1\fs38\fsmilli19224 \cf3 The Power of Stepping Back\

\fs25\fsmilli12816 By stepping back and focusing solely on event coordination, Happen achieves\
something rare in frameworks: it gets out of your way. The framework doesn't\
try to be the center of your application or dictate how you should use the\
runtime. It simply provides the minimal structure needed for nodes to\
communicate through events, then lets your code take center stage.\
This approach creates a unique developer experience:\
\cf5 1. \cf3 Low Cognitive Load: There's no need to learn framework-specific ways to\
access runtime features\
\cf5 2. \cf3 Maximum Flexibility: Your code can use the runtime however it needs\
without framework constraints\
\cf5 3. \cf3 Future-Proof: As runtimes evolve, your code can immediately leverage\
new capabilities\
\cf5 4. \cf3 True Simplicity: The framework does one thing well (event coordination)\
and leaves the rest to your code\
Happen's runtime philosophy embodies its commitment to simplicity. By\
focusing solely on event coordination and giving your code direct access to\
the runtime, Happen creates a framework that is both minimal and powerful.\
This approach recognizes that the most powerful frameworks are often those\
that do less, not more. By stepping back and letting your code work directly\
with the runtime, Happen achieves a rare balance: it provides enough\
structure to create sophisticated event-driven systems while imposing\
minimal constraints on how those systems are implemented.\
The result is a framework that truly embodies its name: it helps things happen\
without dictating how they happen.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 14 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Quick Start\

\fs25\fsmilli12816 Welcome to Happen, a framework for building agentic systems founded on a\
philosophy of simplicity. Unlike conventional frameworks that burden\
developers with complex abstractions, Happen provides just two fundamental\
building blocks that can be composed to create systems ranging from simple\
pipelines to complex, adaptive multi-agent ecosystems.\
Happen distills agent-based systems down to their essence, recognizing that\
true power emerges from simplicity rather than complexity. At its foundation\
lie just two primitives:\
\cf5 1. \cf3 Nodes - Independent, autonomous components that process and respond\
to information\
\cf5 2. \cf3 Events - Structured messages that transport data and intentions between\
Nodes\
This deliberate minimalism creates a framework that is both accessible to\
newcomers and powerful enough for experts, allowing developers to focus on\
solving domain problems rather than battling framework complexities.\

\fs38\fsmilli19224 Setup and Initialization\

\fs25\fsmilli12816 To get started with Happen, first initialize the framework with your desired\
configuration:\

\fs22\fsmilli11214 // Initialize Happen with NATS as the communication fabric\
const happen = initializeHappen(\{\
// NATS configuration\
nats: \{\
// Connection configuration\
connection: \{\
// Server environment (direct NATS)\
server: \{\
servers: ['nats://localhost:4222'],\
jetstream: true\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 15 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 jetstream: true\
\},\
// Browser environment (WebSocket)\
browser: \{\
servers: ['wss://localhost:8443'],\
jetstream: true\
\}\
\}\
\}\
\});\
// Extract the createNode function\
const \{ createNode \} = happen;\

\fs25\fsmilli12816 For simpler use cases, you can use the default configuration:\

\fs22\fsmilli11214 // Use default configuration with local NATS server\
const \{ createNode \} = initializeHappen();\

\fs38\fsmilli19224 Pure Causality: The Secret to Happen's Power\

\fs25\fsmilli12816 The most distinctive aspect of Happen is its embrace of pure causality as its\
organizing principle. This approach eliminates entire categories of complexity\
found in other systems.\
In Happen:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Events can only be created when their prerequisites exist\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Every event contains references to its causal predecessors\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Each event has a unique identifier that gets referenced by its dependents\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 These references form a complete causal web that defines system\
behavior\
This means that knowledge about the system is encoded directly in event flow\
patterns. Nodes don't need schema definitions or formal contracts to\
understand how to interact - they simply need to observe the event flow.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 16 of 234Happen\
7/7/25, 07:52\

\f1\fs38\fsmilli19224 \cf3 The Event Continuum: Programmable Flow Control\

\fs25\fsmilli12816 One of Happen's most powerful features is the "Event Continuum" model,\
which gives you complete control over event handling and flow transitions.\
Unlike typical event handlers that simply execute and complete, Happen\
handlers can control what happens next:\

\fs22\fsmilli11214 // Register an event handler - the first step in processing\
orderNode.on("process-order", function validateOrder(event,\
context) \{\
// Validate the order\
const validation = validateOrderData(event.payload);\
if (!validation.valid) \{\
// Return a value to complete the flow with an error\
return \{\
success: false,\
reason: "validation-failed",\
errors: validation.errors\
\};\
\}\
// Store validation result in context for later steps\
context.validation = validation;\
// Return the next function to execute - controlling the\
transition\
return processPayment;\
\});\
// The next function in the flow\
function processPayment(event, context) \{\
// Access data from previous step through context\
const validatedOrder = context.validation;\
// Process payment\
const paymentResult = processTransaction(validatedOrder);\
if (!paymentResult.success) \{\
// Return a value to complete with failure\
return \{\
success: false,\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 17 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 success: false,\
reason: "payment-failed"\
\};\
\}\
// Store payment result in context\
context.payment = paymentResult;\
// Return the next function to transition to\
return createShipment;\
\}\
// Final step in the flow\
function createShipment(event, context) \{\
// Access data from previous steps\
const \{ payment, validation \} = context;\
// Create shipment\
const shipment = generateShipment(validation.address);\
// Return final result to complete the flow\
return \{\
success: true,\
orderId: validation.orderId,\
paymentId: payment.transactionId,\
trackingNumber: shipment.trackingNumber\
\};\
\}\

\fs25\fsmilli12816 This functional flow approach means:\
\cf5 1. \cf3 Explicit Transitions: You control what happens next by returning either a\
value (to complete) or a function (to continue)\
\cf5 2. \cf3 Shared Context: Information flows between steps through the context\
object\
\cf5 3. \cf3 Natural Branching: Flow can branch based on conditions without complex\
routing rules\
\cf5 4. \cf3 Composable Workflows: Complex flows emerge from simple, focused\
functions\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 18 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 The Event Continuum model enables remarkably clean and readable code for\
complex workflows while maintaining full control over transitions.\

\fs38\fsmilli19224 The Causal Event Web\

\fs25\fsmilli12816 When a node receives this event, it automatically knows:\

\fs22\fsmilli11214 // An event naturally references its causal predecessors\
\{\
type: 'order-shipped',\
payload: \{\
orderId: 'ORD-123',\
trackingNumber: 'TRK-456'\
\},\
context: \{\
// ...\
causal: \{\
id: 'evt-789', // Unique identifier\
sender: 'shipping-node', // Origin node\
causationId: 'evt-456', // Direct cause (payment\
confirmation)\
correlationId: 'order-123' // Overall transaction\
\}\
\}\
\}\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 This event was caused by event 'evt-456'\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 It's part of the transaction 'order-123'\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 It originated from 'shipping-node'\
The entire history and context are embedded in the event itself.\
This pure causality model means:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 No need for schema registries\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 No explicit contract definitions\

\f2\fs38\fsmilli19224 \cf5 \'95\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 19 of 234Happen\
7/7/25, 07:52\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 No capability discovery protocols\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 No separate identity systems\
The system self-describes through its natural operation, with each event\
reinforcing the web of causality that defines how components interact.\

\fs38\fsmilli19224 Building Your First Happen System\

\fs25\fsmilli12816 Let's create a simple order processing system to demonstrate Happen's\
principles in action:\
First, we'll create autonomous nodes to handle different aspects of our order\
process:\

\fs22\fsmilli11214 // Create independent nodes\
const orderNode = createNode('order-service');\
const inventoryNode = createNode('inventory-service');\
const paymentNode = createNode('payment-service');\
const shippingNode = createNode('shipping-service');\

\fs25\fsmilli12816 Next, we'll define how each node responds to events using the Event\
Continuum:\

\fs22\fsmilli11214 // Order node handles order creation with flow control\
orderNode.on('create-order', function validateOrder(event, context)\
\{\
// Validate order data\
const validation = validateOrderData(event.payload);\
if (!validation.valid) \{\
return \{\
success: false,\
errors: validation.errors\
\};\
\}\
// Generate order ID\
const orderId = generateOrderId();\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 20 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 const orderId = generateOrderId();\
// Transition to inventory check, passing data through context\
context.orderData = \{\
id: orderId,\
items: event.payload.items,\
customer: event.payload.customer\
\};\
return checkInventory;\
\});\
// Additional flow functions defined here...\

\fs25\fsmilli12816 Finally, we'll initialize the system and process an example order:\

\fs22\fsmilli11214 function startOrderSystem() \{\
console.log('Order processing system initialized and ready');\
// Broadcast an order creation event to start the process\
orderNode.broadcast(\{\
type: 'create-order',\
payload: \{\
customer: \{\
id: 'cust-123',\
name: 'Jane Doe',\
email: 'jane@example.com',\
address: \{\
street: '123 Main St',\
city: 'Anytown',\
zip: '12345'\
\}\
\},\
items: [\
\{ id: 'prod-a1', quantity: 2 \},\
\{ id: 'prod-b7', quantity: 1 \}\
]\
\}\
\});\
flow:\
// 1. validateOrder function runs and transitions to\
checkInventory\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\

\f1\fs22\fsmilli11214 \cf3 // The system now autonomously processes this event through the\

\f0\fs14 \cf2 Page 21 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 checkInventory\
// 2. checkInventory function runs and transitions to\
processPayment\
// 3. processPayment function runs and transitions to\
createShipment\
// 4. createShipment function completes the flow and returns a\
result\
// All steps share context and control their own transitions\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \}\
// Start the system\
startOrderSystem();\

\fs38\fsmilli19224 Communication Patterns\

\fs25\fsmilli12816 Happen provides two communication patterns that can be composed to\
create any interaction model:\

\fs32\fsmilli16020 1. System-wide Broadcasting\

\fs25\fsmilli12816 Events are sent to all nodes in the system:\

\fs22\fsmilli11214 // Weather service broadcasts a system-wide alert\
weatherNode.broadcast(\{\
type: 'severe-weather',\
payload: \{\
condition: 'hurricane',\
region: 'Gulf Coast'\
\}\
\});\
// Any node can respond\
emergencyNode.on('severe-weather', event => \{\
deployEmergencyTeams(event.payload.region);\
\});\

\fs32\fsmilli16020 2. Direct Communication\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 22 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Point-to-point request-response interactions:\

\fs22\fsmilli11214 // Direct request with awaited response\
const response = await orderNode.send(paymentNode, \{\
type: 'process-payment',\
payload: \{\
orderId: 'ORD-28371',\
amount: 129.99\
\}\
\});\
// Handle the response\
if (response.success) \{\
completeOrder(response.orderId);\
\}\

\fs25\fsmilli12816 The receiving node knows to return a value because the event context\
automatically includes information about the sender and whether a response\
is expected:\

\fs22\fsmilli11214 // Payment node handling direct communication\
paymentNode.on('process-payment', (event, context) => \{\
// The context contains information about the sender and request\
console.log(context.sender); // 'order-service'\
console.log(context.expectsResponse); // true\
// Process the payment\
const result = processPayment(event.payload.orderId,\
event.payload.amount);\
// Simply returning a value sends it back to the requester\
return \{\
success: result.success,\
transactionId: result.success ? result.transactionId : null,\
status: result.success ? 'approved' : 'declined',\
message: result.message\
\};\
\});\

\fs25\fsmilli12816 This simple mechanism means that nodes don't need to know anything\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 23 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 special about handling direct communication - they just return values from\
their handlers as usual. The Happen framework takes care of routing the\
response back to the sender when a response is expected.\

\fs38\fsmilli19224 Distributed Operation\

\fs25\fsmilli12816 With NATS as the underlying messaging fabric, your Happen system\
automatically works across different processes, machines, and environments.\
The same code works whether nodes are:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 In the same process\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 In different processes on the same machine\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 On different machines in the same network\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 In different environments (server, browser, edge)\
No special configuration is needed - nodes communicate transparently across\
boundaries.\

\fs38\fsmilli19224 Next Steps\

\fs25\fsmilli12816 As you build with Happen, remember these key principles:\
\cf5 1. \cf3 Start Simple: Begin with a few nodes that have clear responsibilities\
\cf5 2. \cf3 Focus on Events: Design meaningful events that capture domain concepts\
\cf5 3. \cf3 Control Transitions: Use function returns to control your flow\
\cf5 4. \cf3 Observe Patterns: Let natural workflows emerge from event interactions\
\cf5 5. \cf3 Compose, Don't Complicate: Combine the basic primitives instead of\
adding complexity\
\cf5 6. \cf3 Embrace Causality: Use the causal event web to reason about your\
system\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 24 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 The power of Happen comes not from complex features or abstractions, but\
from how its minimal primitives combine to create emergent behaviors.\
Ready to explore more? Continue to the Core Concepts section to deepen\
your understanding of nodes, events, and the Happen framework.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 25 of 234Happen\
7/7/25, 07:52\

\f1\fs76\fsmilli38449 \cf3 Basics\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 26 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Core Concepts\

\fs25\fsmilli12816 Events all the way down.\
Happen is built on a minimalist foundation of just two fundamental primitives:\
Nodes and Events. These primitives combine to create all the power of the\
framework without unnecessary complexity.\
At the infrastructure level, these primitives are powered by NATS, a high-\
performance messaging system that provides the backbone for Happen's\
distributed capabilities.\

\fs38\fsmilli19224 Nodes: The Foundation of Happen Systems\

\fs25\fsmilli12816 Nodes are the primary actors in a Happen system. They are independent,\
autonomous components that can:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Receive and process events\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Maintain internal state\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Transform state\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Emit new events\
Conceptually, nodes can represent anything: services, entities, agents,\
processes, or even abstract concepts. This flexibility allows Happen systems\
to model complex domains with remarkable fidelity.\
Unlike traditional components that often require elaborate setup and\
configuration, Happen nodes are intentionally lightweight. They embody a\
biological inspiration\'97like cells in an organism or neurons in a brain\'97simple\
individual units that collectively create sophisticated behaviors through their\
interactions.\

\fs32\fsmilli16020 Creating a Node\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 27 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Creating a node in Happen is achieved by calling the with an identifier and optional config object:\

\fs22\fsmilli11214 createNode() 
\fs25\fsmilli12816 function\

\fs22\fsmilli11214 const orderProcessor = createNode("order-processor", \{\});\

\fs25\fsmilli12816 Every node has a unique identity that distinguishes it within the system:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Identities are cryptographically verifiable\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Nodes act autonomously based on their internal logic\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 A node's behavior is determined by how it processes events and\
transforms state\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Nodes don't need to know about the overall system structure to function\
This autonomy means nodes can be developed, tested, and reasoned about\
independently, dramatically simplifying system development and\
maintenance.\

\fs38\fsmilli19224 Events: The Lifeblood of the System\

\fs25\fsmilli12816 Events are structured messages that flow between nodes, forming the\
lifeblood of any Happen system. They embody the principle that\
communication should be explicit, intentional, and meaningful.\
Unlike traditional method calls or function invocations, events in Happen\
represent meaningful occurrences in the domain\'97things that have happened\
that might be of interest to other parts of the system. This perspective shift\
encourages developers to model their systems in terms of meaningful domain\
events rather than technical procedures.\
Under the hood, Happen uses NATS to transport these events between nodes,\
benefiting from its high-performance, reliable messaging capabilities.\

\fs32\fsmilli16020 Event Anatomy\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 28 of 234Happen\

\f1\fs32\fsmilli16020 \cf3 Event Anatomy\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Events consist of three fundamental parts:\
\cf5 1. \cf3 Type - A string identifier indicating the event's purpose\
\cf5 2. \cf3 Payload - Domain-specific data relevant to the event\
\cf5 3. \cf3 Context - Causal and system information about the event\

\fs22\fsmilli11214 \{\
type: "order-created",\
payload: \{\
orderId: "ORD-123",\
items: [\
\{\
productId: "PROD-456",\
quantity: 2,\
price: 29.99\
\}\
],\
total: 59.98\
\},\
context: \{\
causal: \{\
id: "evt-789", // Unique event identifier\
sender: "checkout-node", // Node that created the event\
causationId: "evt-456", // Event that caused this one\
correlationId: "txn-123", // Transaction/process identifier\
path: ["user-node", "checkout-node"] // Event path\
\},\
// Additional context...\
\}\
\}\

\fs38\fsmilli19224 Event Processing: The Event Continuum\

\fs25\fsmilli12816 Nodes process events through a pure functional flow model we call the "Event\
Continuum." This approach treats event handling as a chain of functions\
where each function determines what happens next through its return value:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 29 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Register an event handler - the entry point to the flow\
orderNode.on("process-order", validateOrder);\
// First function in the flow\
function validateOrder(event, context) \{\
// Validate order\
const validation = validateOrderData(event.payload);\
if (!validation.valid) \{\
return \{ success: false, reason: "Invalid order" \};\
\}\
// Store validation result\
context.validatedOrder = \{\
...event.payload,\
validated: true,\
validatedAt: Date.now()\
\};\
// Return the next function to execute\
return processPayment;\
\}\
// Next function in the flow\
function processPayment(event, context) \{\
// Process payment using data from context\
const paymentResult = processTransaction(event.payload.payment);\
// Store in context\
context.payment = paymentResult;\
if (!paymentResult.success) \{\
// Return a value to complete with failure\
return \{ success: false, reason: "Payment failed" \};\
\}\
// Return next function\
return createShipment;\
\}\
// Final function returning a result value\
function createShipment(event, context) \{\
// Create shipment\
const shipment = generateShipment(event.payload.address);\
// Return final result (not a function)\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 30 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Return final result (not a function)\
return \{\
success: true,\
orderId: event.payload.orderId,\
trackingNumber: shipment.trackingNumber\
\};\
\}\

\fs25\fsmilli12816 This pure functional approach offers remarkable power and flexibility:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Any function can return another function to redirect the flow\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Any function can return a non-function value to complete the flow\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 A shared context object allows communication between functions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Complex workflows emerge naturally from function composition\

\fs38\fsmilli19224 State and Persistence\

\fs25\fsmilli12816 Nodes can maintain state that persists between events. Happen provides a\
clean, functional approach to accessing and updating state through pattern\
matching and transformations.\
Under the hood, this state is persisted in NATS JetStream's Key-Value store,\
providing durable, distributed state management without requiring custom\
persistence implementations.\

\fs32\fsmilli16020 Accessing State\

\fs22\fsmilli11214 // Access the entire node state\
const orderState = orderNode.state.get();\
// Transform state before returning\
const orders = orderNode.state.get(state => state.backlog);\
// Access and transform state\
const correctedBatch = orderNode.state.get(state => \{\
// Transform the state\
return state.orders.map(order => (\{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 31 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 return state.orders.map(order => (\{\
...order,\
total: recalculateTotal(order)\
\}));\
\});\

\fs32\fsmilli16020 Transforming State\

\fs25\fsmilli12816 You can transform state using a single function approach:\

\fs22\fsmilli11214 // Transform state without pattern matching\
orderNode.state.set((state) => \{\
// Update transformed state\
return \{\
...state,\
orders: \{\
...state.orders,\
"order-123": \{\
...state.orders["order-123"],\
status: "shipped",\
shippedAt: Date.now()\
\}\
\}\
\};\
\});\

\fs25\fsmilli12816 For more focused updates, you can create specific transformers:\

\fs22\fsmilli11214 // Define transformer for shipping an order\
const shipOrder = (orderId) => (state) => (\{\
...state,\
orders: \{\
...state.orders,\
[orderId]: \{\
...state.orders[orderId],\
status: "shipped",\
shippedAt: Date.now()\
\}\
\}\
\});\
// Apply transformer\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 32 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Apply transformer\
orderNode.state.set(shipOrder("order-123"));\

\fs38\fsmilli19224 The Causality Web\

\fs25\fsmilli12816 Underlying Happen's approach is the concept of pure causality, where every\
event is part of a causal chain. This is implemented through the metadata in\
each event:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs22\fsmilli11214 \cf3 causationId 
\fs25\fsmilli12816 : References the event that directly caused this one\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs22\fsmilli11214 \cf3 correlationId 
\fs25\fsmilli12816 : Groups events that are part of the same transaction or\
process\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs22\fsmilli11214 \cf3 path 
\fs25\fsmilli12816 : Shows the journey the event has taken through the system\
This causal relationship creates a complete web of events that defines the\
system's behavior without requiring explicit schema definitions, contracts, or\
capability discovery protocols.\

\fs38\fsmilli19224 Uniting Event Processing and State Transformation\

\fs25\fsmilli12816 What makes Happen truly powerful is how the Event Continuum and state\
transformations work together:\

\fs22\fsmilli11214 // Process event with the Event Continuum\
orderNode.on("update-order-status", (event, context) => \{\
// Validate status change\
const validationResult = validateStatusChange(\
event.payload.orderId,\
event.payload.status\
);\
if (!validationResult.valid) \{\
return \{\
success: false,\
reason: validationResult.reason\
\};\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 33 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \};\
\}\
// Store in context\
context.orderId = event.payload.orderId;\
context.newStatus = event.payload.status;\
// Apply state transformation\
return applyStatusChange;\
\});\
// Function that applies state transformation\
function applyStatusChange(event, context) \{\
const \{ orderId, newStatus \} = context;\
// Transform state\
orderNode.state.set(state => \{\
const orders = state.orders || \{\};\
const order = orders[orderId];\
if (!order) \{\
return state;\
\}\
return \{\
...state,\
orders: \{\
...orders,\
[orderId]: \{\
...order,\
status: newStatus,\
updatedAt: Date.now()\
\}\
\}\
\};\
\});\
// Emit another event based on the state change\
orderNode.broadcast(\{\
type: "order-status-changed",\
payload: \{\
orderId,\
status: newStatus\
\}\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 34 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Return success result\
return \{\
success: true,\
orderId,\
status: newStatus\
\};\
\}\

\fs25\fsmilli12816 This unified approach allows you to seamlessly combine the reactive, event-\
driven flow with the consistent, state-focused transformations, giving you the\
best of both worlds.\

\fs38\fsmilli19224 NATS: The Underlying Fabric\

\fs25\fsmilli12816 While Happen's conceptual model is built around Nodes and Events, the\
framework leverages NATS as its underlying messaging fabric to provide:\
\cf5 1. \cf3 Distributed Messaging: High-performance communication between\
nodes, even across network boundaries\
\cf5 2. \cf3 Persistence: Durable storage of events and state through JetStream\
\cf5 3. \cf3 Exactly-Once Processing: Guaranteed message delivery and processing\
semantics\
\cf5 4. \cf3 Cross-Environment Operation: Unified communication across server,\
browser, and edge environments\
This foundation ensures that Happen systems are not only conceptually clean\
but also robust and resilient in real-world distributed environments.\
Now that you understand the core concepts of Happen, you're ready to\
explore how these primitives combine to create powerful communication\
patterns and sophisticated system behaviors.\
In the next section, we'll explore event pattern matching and how it enables\
powerful selective event handling.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 35 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Event Pattern Matching\

\fs25\fsmilli12816 In Happen, we've taken a different approach to event pattern matching.\
Instead of providing complex pattern syntax with its own parsing rules and\
limitations, we leverage JavaScript's first-class functions to give you complete\
freedom in defining how events should be matched.\

\fs38\fsmilli19224 Function-Based Matchers\

\fs25\fsmilli12816 At its core, a pattern in Happen is simply a function that decides whether an\
event should be handled:\

\fs22\fsmilli11214 // A pattern is a function that returns true or false for an event\
type\
node.on(eventType => eventType === 'order.submitted', (event,\
context) => \{\
// Process order submission\
// ...\
// Return next function or result\
return processPayment;\
\});\

\fs25\fsmilli12816 This function receives the event's type string and returns a boolean: true if the\
event should be handled, false if it should be ignored.\
This simple approach provides extraordinary flexibility:\

\fs22\fsmilli11214 // Match exact event type\
node.on(type => type === 'order.submitted', handleOrderSubmission);\
// Match events by domain prefix\
node.on(type => type.startsWith('order.'), (event, context) => \{\
// Log all order events\
logOrderEvent(event);\
// Continue to domain-specific handler\
return getDomainSpecificHandler(event.type);\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 36 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 \});\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Match multiple specific events\
node.on(type => ['payment.succeeded',\
'payment.failed'].includes(type),\
function(event, context) \{\
// Process payment result\
processPaymentResult(event);\
// Branch based on success or failure\
return event.type === 'payment.succeeded' ?\
handlePaymentSuccess : handlePaymentFailure;\
\}\
);\
// Match with regular expressions\
node.on(type => /^user\\.(created|updated|deleted)$/.test(type),\
function(event, context) \{\
// Handle user lifecycle event\
updateUserCache(event);\
// Determine next step based on event type\
const actions = \{\
'user.created': notifyUserCreated,\
'user.updated': notifyUserUpdated,\
'user.deleted': notifyUserDeleted\
\};\
// Return appropriate next function\
return actions[event.type];\
\}\
);\
// Complex conditional matching\
node.on(type => \{\
const [domain, action] = type.split('.');\
return domain === 'inventory' && action.includes('level');\
\}, function(event, context) \{\
// Process inventory level event\
processInventoryLevel(event);\
// Check if restock needed\
if (isRestockNeeded(event.payload)) \{\
return createRestockOrder;\
\}\
\});\
// Otherwise complete\
return \{ processed: true \};\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 37 of 234Happen\
7/7/25, 07:52\

\f1\fs38\fsmilli19224 \cf3 Creating Your Own Pattern System\

\fs25\fsmilli12816 With function-based matchers, you can build any pattern matching system\
that suits your needs. Here's an example of how you might create your own\
pattern utilities:\

\fs22\fsmilli11214 // Create a domain matcher\
function domain(name) \{\
return type => type.startsWith(`$\{name\}.`);\
// Create an exact matcher\
function exact(fullType) \{\
return type => type === fullType;\
\}\
\}\
// Create a wildcard matcher\
function wildcard(pattern) \{\
// Convert the pattern to a regex\
const regex = new RegExp('^' + pattern.replace(/\\./g,\
'\\\\.').replace(/\\*/g, '.*') + '$');\
return type => regex.test(type);\
\}\
// Create a matcher for multiple patterns\
function oneOf(...patterns) \{\
return type => patterns.some(pattern =>\
typeof pattern === 'function' ? pattern(type) : type ===\
pattern\
);\
\}\
// Create a matcher that excludes patterns\
function not(pattern) \{\
const matcher = typeof pattern === 'function' ? pattern : type =>\
type === pattern;\
return type => !matcher(type);\
\}\

\fs25\fsmilli12816 Now you can use these utilities to create expressive, reusable matchers:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 38 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Match all order events\
node.on(domain('order'), (event, context) => \{\
// Process all order events\
logOrderEvent(event);\
// Continue to specific handler based on event type\
const actionType = event.type.split('.')[1];\
return getHandlerForAction(actionType);\
\});\
// Match a specific event exactly\
node.on(exact('payment.succeeded'), (event, context) => \{\
// Process successful payment\
updateOrderPaymentStatus(event.payload);\
// Continue to shipping\
return createShipment;\
\});\
// Match using wildcards\
node.on(wildcard('user.*.completed'), (event, context) => \{\
// Handle user completion events\
trackUserCompletion(event);\
// Determine next steps\
return selectNextUserAction;\
\});\
// Match any of multiple patterns\
node.on(oneOf(\
exact('order.submitted'),\
exact('payment.succeeded'),\
wildcard('shipping.*')\
), (event, context) => \{\
// Handle important events\
notifyAdmins(event);\
// Continue to regular processing\
return processNormally;\
\});\
// Match one domain but exclude specific events\
node.on(\
type => domain('user')(type) && not(exact('user.password-\
changed'))(type),\
(event, context) => \{\
// Handle non-sensitive user events\
logUserAction(event);\
// Continue to specific handler
\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 39 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Continue to specific handler\
return getHandlerForUserAction(event.type);\
\}\
);\

\fs38\fsmilli19224 String Pattern Support\

\fs25\fsmilli12816 For convenience, Happen also supports string patterns which are converted\
to matcher functions internally:\

\fs22\fsmilli11214 // These are equivalent\
node.on('order.submitted', handleOrderSubmission);\
node.on(type => type === 'order.submitted', handleOrderSubmission);\
// These are equivalent too\
node.on('order.*', handleAllOrderEvents);\
node.on(type => type.startsWith('order.') && !type.includes('.',\
type.indexOf('.') + 1), handleAllOrderEvents);\

\fs25\fsmilli12816 String patterns support several features:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Exact matching: 'order.submitted'\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Wildcards: 'order.*'\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Alternative patterns: '\{order,payment\}.created'\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Multiple segments: 'user.profile.*'\
However, function matchers provide greater flexibility and expressiveness\
when you need more complex matching logic.\

\fs38\fsmilli19224 Building Domain-Specific Pattern Systems\

\fs25\fsmilli12816 For larger applications, you might want to build a more structured pattern\
system. Here's an example of a domain-oriented approach:\

\fs22\fsmilli11214 // Create a domain builder\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 40 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Create a domain builder\
function createDomain(name) \{\
// Basic event matcher creator\
function eventMatcher(action) \{\
return type => type === `$\{name\}.$\{action\}`;\
\}\
utilities\
// Return a function that can be called directly or accessed for\
const domain = eventMatcher;\
// Add utility methods\
domain.all = () => type => type.startsWith(`$\{name\}.`);\
domain.oneOf = (...actions) => type => \{\
const prefix = `$\{name\}.`;\
return type.startsWith(prefix) &&\
actions.includes(type.slice(prefix.length));\
\};\
return domain;\
\}\
// Create domains for your application\
const order = createDomain('order');\
const payment = createDomain('payment');\
const user = createDomain('user');\
// Use them in your handlers\
node.on(order('submitted'), (event, context) => \{\
// Handle order submission\
processOrder(event.payload);\
// Return next function\
return validateInventory;\
\});\
node.on(order.all(), (event, context) => \{\
// Log all order events\
logOrderActivity(event);\
// Continue normal processing\
return context.next || null;\
\});\
node.on(payment.oneOf('succeeded', 'failed'), (event, context) => \{\
// Process payment results\
updateOrderWithPayment(event);\
// Branch based on result\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 41 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Branch based on result\
return event.type === 'payment.succeeded' ?\
handleSuccessfulPayment : handleFailedPayment;\
\});\

\fs38\fsmilli19224 Benefits of Function-Based Pattern Matching\

\fs25\fsmilli12816 This approach to pattern matching offers several advantages:\
\cf5 1. \cf3 Unlimited Flexibility: Any matching logic can be implemented\
\cf5 2. \cf3 Zero Parse-Time Overhead: Patterns are just functions, no parsing needed\
\cf5 3. \cf3 Type Safety: TypeScript can fully type your pattern functions\
\cf5 4. \cf3 Testability: Pattern functions can be unit tested independently\
\cf5 5. \cf3 Composition: Combine matchers to create complex patterns\
\cf5 6. \cf3 Familiar JavaScript: No special syntax to learn, just standard JS\

\fs38\fsmilli19224 Best Practices\

\f2 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Keep matcher functions pure: They should depend only on the input event\
type\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Create reusable pattern factories: Build a library of matcher creators for\
your application\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Compose simple matchers: Build complex patterns by combining simple\
ones\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Test your matchers: Unit test complex matching logic independently\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Consider performance: For high-frequency events, optimize your matcher\
functions\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 42 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 The Event Continuum\

\fs25\fsmilli12816 In Happen, we've distilled event processing to its purest essence: a\
continuous flow of functions that process events and determine what\
happens next.\

\fs38\fsmilli19224 The Pure Functional Flow Model\

\fs25\fsmilli12816 At its core, the Event Continuum views event handling as a single entry point\
that can branch into a chain of functions through return values:\

\fs22\fsmilli11214 // Register a single entry point\
orderNode.on("create-order", validateOrder);\
// The flow is controlled by function returns\
function validateOrder(event, context) \{\
if (!isValidOrder(event.payload)) \{\
return \{ success: false, reason: "Invalid order" \};\
\}\
// Return the next function to execute\
return processOrder;\
\}\
function processOrder(event, context) \{\
// Process the order\
const orderId = createOrderInDatabase(event.payload);\
// Store in context\
context.orderId = orderId;\
// Return the next function\
return notifyCustomer;\
\}\
function notifyCustomer(event, context) \{\
// Send notification using context data\
sendOrderConfirmation(context.orderId, event.payload.customer);\
// Return final result\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 43 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Return final result\
return \{ success: true, orderId: context.orderId \};\
\}\

\fs25\fsmilli12816 This creates an elegant flow system with just one fundamental mechanism:\
functions that return either the next function or a final value.\

\fs38\fsmilli19224 How the Continuum Works\

\fs25\fsmilli12816 When an event arrives at a node, the system:\
\cf5 1. \cf3 Calls the registered handler function\
\cf5 2. \cf3 Examines the return value:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 If it's a function: Execute that function next\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 If it's any other value: Complete the flow with that value as the result\
This simple mechanism creates a remarkably powerful and flexible flow\
system.\

\fs38\fsmilli19224 Flow Control Through Return Values\

\fs25\fsmilli12816 The Event Continuum achieves its power through a pure functional approach:\

\fs32\fsmilli16020 Continuing to the Next Step\

\fs25\fsmilli12816 When a handler returns another function, the flow continues with that\
function:\

\fs22\fsmilli11214 function checkInventory(event, context) \{\
// Check inventory\
const inventoryResult = validateStock(event.payload.items);\
if (!inventoryResult.available) \{\
return handleInventoryShortage;\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 44 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \}\
// Continue to payment processing\
return processPayment;\
\}\

\fs32\fsmilli16020 Completing the Flow with a Result\

\fs25\fsmilli12816 When a handler returns any non-function value, the flow completes with that\
value as the result:\

\fs22\fsmilli11214 function processPayment(event, context) \{\
// Process payment\
const paymentResult = chargeCustomer(event.payload.payment);\
if (!paymentResult.success) \{\
// Complete with failure result\
return \{\
success: false,\
reason: "payment-failed",\
details: paymentResult.error\
\};\
\}\
// Continue to shipping\
return createShipment;\
\}\

\fs32\fsmilli16020 Dynamic Flow Selection\

\fs25\fsmilli12816 Functions can return different next steps based on any condition:\

\fs22\fsmilli11214 function determinePaymentMethod(event, context) \{\
// Choose next step based on payment method\
const method = event.payload.paymentMethod;\
// Return different functions based on conditions\
if (method === "credit-card") \{\
return processCreditCard;\
\} else if (method === "paypal") \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 45 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \} else if (method === "paypal") \{\
return processPaypal;\
\} else \{\
return processAlternativePayment;\
\}\
\}\

\fs38\fsmilli19224 Shared Context\

\fs25\fsmilli12816 A shared context object flows through the function chain, allowing\
communication between steps:\

\fs22\fsmilli11214 function validateOrder(event, context) \{\
// Store validation result in context\
context.validation = validateOrderData(event.payload);\
if (!context.validation.valid) \{\
return \{ success: false, errors: context.validation.errors \};\
\}\
return processInventory;\
\}\
function processInventory(event, context) \{\
// Access context from previous step\
const validatedItems = context.validation.items;\
// Add more to context\
context.inventory = checkInventoryForItems(validatedItems);\
return processPayment;\
\}\

\fs25\fsmilli12816 This provides a clean way for functions to build up state as the flow\
progresses.\

\fs38\fsmilli19224 Complex Flow Patterns\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 46 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 The pure functional model supports sophisticated flow patterns:\

\fs32\fsmilli16020 Conditional Branching\

\fs22\fsmilli11214 function processOrder(event, context) \{\
// Branch based on order type\
if (event.payload.isRush) \{\
return processRushOrder;\
\} else if (event.payload.isInternational) \{\
return processInternationalOrder;\
\} else \{\
return processStandardOrder;\
\}\
\}\

\fs32\fsmilli16020 Loop Patterns\

\fs25\fsmilli12816 You can create loops by returning a function that's already been executed:\

\fs22\fsmilli11214 function processItems(event, context) \{\
// Initialize if first time\
if (!context.itemIndex) \{\
context.itemIndex = 0;\
context.results = [];\
\}\
// Get current item\
const items = event.payload.items;\
const currentItem = items[context.itemIndex];\
// Process current item\
const result = processItem(currentItem);\
context.results.push(result);\
// Increment index\
context.itemIndex++;\
// Loop if more items\
if (context.itemIndex < items.length) \{\
return processItems; // Loop back to this function\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 47 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \}\
// Otherwise, continue to next handler\
return summarizeResults;\
\}\

\fs32\fsmilli16020 Error Handling Patterns\

\fs25\fsmilli12816 Error handling becomes part of the natural flow:\

\fs22\fsmilli11214 function processPayment(event, context) \{\
try \{\
// Attempt to process payment\
const result = chargeCustomer(event.payload.payment);\
context.payment = result;\
// Continue to shipping\
return createShipment;\
\} catch (error) \{\
// Handle error\
context.error = error;\
// Branch to error handler\
return handlePaymentError;\
\}\
\}\
function handlePaymentError(event, context) \{\
// Log error\
logPaymentFailure(context.error);\
// Return error result\
return \{\
success: false,\
reason: "payment-failed",\
error: context.error.message\
\};\
\}\

\fs38\fsmilli19224 Building Complete Workflows\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 48 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 The Event Continuum naturally supports building complex workflows:\

\fs22\fsmilli11214 // Entry point\
orderNode.on("process-order", validateOrder);\
// Define workflow steps as functions\
function validateOrder(event, context) \{\
const validation = performValidation(event.payload);\
if (!validation.valid) \{\
return \{ success: false, errors: validation.errors \};\
\}\
// Store in context and continue\
context.validation = validation;\
return checkInventory;\
\}\
function checkInventory(event, context) \{\
const inventoryResult = checkStockLevels(event.payload.items);\
if (!inventoryResult.available) \{\
return handleInventoryShortage;\
\}\
// Store in context and continue\
context.inventory = inventoryResult;\
return processPayment;\
\}\
function processPayment(event, context) \{\
const paymentResult = processTransaction(event.payload.payment);\
if (!paymentResult.success) \{\
return handlePaymentFailure;\
\}\
// Store in context and continue\
context.payment = paymentResult;\
return createShipment;\
\}\
function createShipment(event, context) \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 49 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 function createShipment(event, context) \{\
// Create shipment\
const shipment = generateShipment(event.payload.address,\
event.payload.items);\
context.shipment = shipment;\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 return finalizeOrder;\
\}\
function finalizeOrder(event, context) \{\
// Finalize the order\
const finalOrder = \{\
orderId: generateOrderId(),\
customer: event.payload.customer,\
payment: context.payment,\
shipment: context.shipment,\
status: "completed"\
\};\
// Save order\
saveOrderToDatabase(finalOrder);\
// Return final result\
return \{\
success: true,\
order: finalOrder\
\};\
\}\
// Error handling functions\
function handleInventoryShortage(event, context) \{\
notifyInventoryTeam(event.payload.items);\
return \{\
success: false,\
reason: "inventory-shortage",\
availableOn: estimateRestockDate(event.payload.items)\
\};\
\}\
function handlePaymentFailure(event, context) \{\
// Log failure\
logPaymentFailure(event.payload.payment);\
return \{\
success: false,\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 50 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 success: false,\
reason: "payment-failed",\
paymentError: context.payment.error\
\};\
\}\

\fs38\fsmilli19224 The Power of Pure Functional Flows\

\fs25\fsmilli12816 This pure functional approach offers several benefits:\
\cf5 1. \cf3 Ultimate Simplicity: One consistent pattern for all event handling\
\cf5 2. \cf3 Maximum Flexibility: Functions can compose and branch in unlimited\
ways\
\cf5 3. \cf3 Transparent Logic: Flow control is explicit in function returns\
\cf5 4. \cf3 Perfect Testability: Each function can be tested independently\
\cf5 5. \cf3 Minimal API Surface: Just 
\fs22\fsmilli11214 .on() 
\fs25\fsmilli12816 with a single handler\
This approach embodies Happen's philosophy in its purest form - a single\
registration method and function returns create a system of unlimited\
expressiveness.\

\fs38\fsmilli19224 Examples of the Event Continuum in Action\

\fs32\fsmilli16020 Simple Event Handling\

\fs22\fsmilli11214 // Simple handler that completes immediately\
orderNode.on("order-created", (event) => \{\
console.log("Order created:", event.payload.id);\
return \{ acknowledged: true \};\
\});\

\fs32\fsmilli16020 Validation Pattern\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 51 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Entry point with validation\
orderNode.on("create-user", (event) => \{\
const validation = validateUserData(event.payload);\
if (!validation.valid) \{\
return \{ success: false, errors: validation.errors \};\
\}\
// Continue to user creation\
return createUserRecord;\
\});\
function createUserRecord(event, context) \{\
// Create user in database\
const userId = createUser(event.payload);\
// Return success\
return \{ success: true, userId \};\
\}\

\fs38\fsmilli19224 Request-Response with Direct Return\

\fs22\fsmilli11214 // Direct communication with explicit return\
dataNode.on("get-user-data", (event, context) => \{\
const \{ userId, fields \} = event.payload;\
// Fetch user data\
const userData = fetchUserData(userId, fields);\
// Return directly to requester - this value will be sent back\
return userData;\
\});\

\fs38\fsmilli19224 Ending Flow with Bare Return\

\fs25\fsmilli12816 A bare 
\fs22\fsmilli11214 return 
\fs25\fsmilli12816 statement will end the flow without returning any value:\

\fs22\fsmilli11214 // End flow with a bare return statement\
dataNode.on("log-activity", (event, context) => \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 52 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 dataNode.on("log-activity", (event, context) => \{\
// Log the activity\
logUserActivity(event.payload.userId, event.payload.action);\
// End the flow with a bare return\
return;\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \});\

\fs25\fsmilli12816 This is equivalent to returning 
\fs22\fsmilli11214 undefined 
\fs25\fsmilli12816 intention to end the flow without a value.\
but is more explicit about the\

\fs38\fsmilli19224 Building Reusable Flow Patterns\

\fs25\fsmilli12816 The functional nature of the Event Continuum encourages building reusable\
patterns:\

\fs22\fsmilli11214 // Create a validation wrapper\
function withValidation(validator, nextStep) \{\
return function(event, context) \{\
const validation = validator(event.payload);\
if (!validation.valid) \{\
return \{ success: false, errors: validation.errors \};\
\}\
// Store validation result\
context.validation = validation;\
// Continue to next step\
return nextStep;\
\};\
\}\
// Create a retry wrapper\
function withRetry(handler, maxRetries = 3) \{\
return function retryHandler(event, context) \{\
// Initialize retry count\
context.retryCount = context.retryCount || 0;\
try \{\
// Attempt to execute handler\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 53 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Attempt to execute handler\
return handler(event, context);\
\} catch (error) \{\
// Increment retry count\
context.retryCount++;\
// Check if we can retry\
if (context.retryCount <= maxRetries) \{\
console.log(`Retrying\
($\{context.retryCount\}/$\{maxRetries\})...`);\
return retryHandler; // Recurse to retry\
\}\
// Too many retries\
return \{\
success: false,\
error: error.message,\
retries: context.retryCount\
\};\
\}\
\};\
\}\
// Usage\
orderNode.on("create-order",\
withValidation(validateOrder,\
withRetry(processOrder)\
)\
);\

\fs38\fsmilli19224 Parallel Processing\

\fs25\fsmilli12816 For more advanced scenarios, you can implement parallel processing:\

\fs22\fsmilli11214 // Parallel execution helper\
function parallel(functions) \{\
return async function(event, context) \{\
// Execute all functions in parallel\
const results = await Promise.all(\
functions.map(fn => fn(event, context))\
);\
// Store results\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 54 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Store results\
context.parallelResults = results;\
// Return the continuation function\
return context.continuation;\
\};\
\}\
// Usage\
orderNode.on("process-order", (event, context) => \{\
// Set up the continuation\
context.continuation = finalizeOrder;\
// Execute these functions in parallel\
return parallel([\
validateInventory,\
processPayment,\
prepareShipping\
]);\
\});\
function finalizeOrder(event, context) \{\
// Access results from parallel execution\
const [inventoryResult, paymentResult, shippingResult] =\
context.parallelResults;\
// Proceed based on all results\
if (inventoryResult.success && paymentResult.success &&\
shippingResult.success) \{\
return \{ success: true, order:\
combineResults(context.parallelResults) \};\
\} else \{\
return \{ success: false, failures:\
findFailures(context.parallelResults) \};\
\}\
\}\

\fs25\fsmilli12816 By treating event handling as a pure functional flow where each function\
determines what happens next, Happen enables a system of unlimited\
expressiveness that can handle everything from simple events to complex\
workflows with the same consistent pattern.\
Ready to explore more? Continue to the Communication Patterns section to\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 55 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 see how the Event Continuum integrates with other aspects of the Happen\
framework.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 56 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Communication Patterns\

\fs25\fsmilli12816 The lifeblood of any Happen system is communication between nodes.\
Happen distills communication down to fundamental patterns that can be\
composed to create any interaction model.\

\fs38\fsmilli19224 System-wide Broadcasting\

\fs25\fsmilli12816 System-wide broadcasting creates an environment where information flows\
freely throughout the entire ecosystem. Any node can transmit events that\
propagate across the system, reaching all nodes without targeting specific\
recipients.\

\fs22\fsmilli11214 // Weather monitoring service broadcasts a system-wide alert\
weatherMonitor.broadcast(\{\
type: "severe-weather",\
payload: \{\
condition: "hurricane",\
region: "Gulf Coast",\
expectedImpact: "severe",\
timeframe: "36 hours",\
\},\
\});\
// Any node in the system can listen for these alerts\
emergencyServices.on(type => type === "severe-weather", event => \{\
deployEmergencyTeams(event.payload.region);\
\});\

\fs25\fsmilli12816 Broadcasting is ideal for:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 System-wide notifications\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Important state changes that many nodes might care about\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Environmental changes affecting the entire system\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Crisis or exceptional condition alerts\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 57 of 234Happen\
7/7/25, 07:52\

\f1\fs38\fsmilli19224 \cf3 Direct Communication\

\fs25\fsmilli12816 Direct communication establishes dedicated point-to-point channels between\
nodes, enabling private exchanges, guaranteed delivery, and response-\
oriented interactions.\

\fs32\fsmilli16020 Request-Response Pattern\

\fs22\fsmilli11214 // Order service directly communicates with payment service\
async function processOrder(event, context) \{\
// Send to payment service and await response using .return()\
const result = await orderNode.send(paymentNode, \{\
type: "process-payment",\
payload: \{\
orderId: event.payload.orderId,\
amount: calculateTotal(event.payload.items),\
currency: "USD",\
customerId: event.payload.customerId,\
\}\
\}).return();\
// Handle the response\
if (result.status === "approved") \{\
return createShipment;\
\} else \{\
return handlePaymentFailure;\
\}\
\}\
// Payment service handles the request\
paymentNode.on("process-payment", event => \{\
// Process the payment\
const result = chargeCustomer(event.payload);\
// Return result directly\
return \{\
status: result.success ? "approved" : "declined",\
transactionId: result.transactionId,\
message: result.message\
\};\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 58 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 \});\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 The 
\fs22\fsmilli11214 .return() 
\fs25\fsmilli12816 method explicitly indicates that you're expecting a response,\
making the code more readable and intention-clear. The receiving node\
simply returns a value from its handler as usual.\

\fs32\fsmilli16020 Response Handling with Callbacks\

\fs25\fsmilli12816 For more sophisticated response handling, you can provide a callback to\

\fs22\fsmilli11214 .return() 
\fs25\fsmilli12816 :\

\fs22\fsmilli11214 // Send request and handle response with a callback\
orderNode.send(inventoryNode, \{\
type: "check-inventory",\
payload: \{ itemId: "123", quantity: 5 \}\
\}).return(response => \{\
if (response.available) \{\
processAvailableItem(response);\
\} else \{\
handleOutOfStock(response);\
\}\
\});\

\fs32\fsmilli16020 Fire-and-Forget Communication\

\fs25\fsmilli12816 When no response is needed, simply don't call 
\fs22\fsmilli11214 .return() 
\fs25\fsmilli12816 :\

\fs22\fsmilli11214 // Notification without needing a response\
function notifyCustomer(event, context) \{\
// Send notification without calling .return()\
orderNode.send(emailNode, \{\
type: "send-email",\
payload: \{\
to: event.payload.customerEmail,\
subject: "Order Confirmation",\
orderId: event.payload.orderId\
\}\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 59 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Continue processing immediately\
return finalizeOrder;\
\}\
// Email node doesn't need to return anything\
emailNode.on("send-email", event => \{\
sendCustomerEmail(event.payload);\
// No explicit return needed for fire-and-forget\
\});\

\fs25\fsmilli12816 This approach has several advantages:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 The sending node clearly indicates its expectations\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 The API is more extensible for future enhancements\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 It provides a cleaner way to handle responses\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 It avoids relying on node context details\
Direct communication is best for:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Request-response interactions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Private or sensitive information exchange\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Operations requiring acknowledgment\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Complex workflows requiring coordination\

\fs38\fsmilli19224 Implicit Contracts\

\fs25\fsmilli12816 In Happen, contracts between nodes emerge naturally from event patterns:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 A node's interface is defined by the events it handles and emits\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 The causal relationships between events form a natural contract\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 New nodes can understand existing patterns through observation\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Contracts can evolve naturally as systems change\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 60 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 This emergent approach eliminates the need for formal interface definitions or\
schema registries.\

\fs38\fsmilli19224 Choosing the Right Pattern\

\fs25\fsmilli12816 While Happen allows you to freely mix communication patterns, here are\
some guidelines:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Use broadcasting when information needs to reach multiple recipients\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Use direct communication for targeted interactions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Use 
\fs22\fsmilli11214 .return() 
\fs25\fsmilli12816 when you need a response\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Skip 
\fs22\fsmilli11214 .return() 
\fs25\fsmilli12816 for fire-and-forget operations\
The right combination of patterns will depend on your specific domain and\
requirements. By leveraging these fundamental communication patterns and\
composing them in different ways, you can create a wide range of interaction\
models that fit your specific needs.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 61 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Confluence\

\fs38\fsmilli19224 Unified Fan-in and Fan-out Event Processing\

\fs25\fsmilli12816 Confluence is Happen's system for handling multiple events and multiple\
nodes with minimal API surface. It provides powerful capabilities for both\
event batching (fan-in) and multi-node distribution (fan-out) through a single,\
intuitive container pattern.\

\fs38\fsmilli19224 Core Idea\

\fs25\fsmilli12816 Confluence embodies a simple concept: When something is in a container, it\
represents a collection. This principle applies consistently whether you're\
working with nodes or events:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 An array of nodes means "multiple receivers"\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 An array of events means "a batch of events"\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Handlers naturally work with both individual items and collections\
This symmetry creates a powerful system with virtually no new API surface.\

\fs38\fsmilli19224 API Surface\

\fs25\fsmilli12816 The entire Confluence system introduces zero new methods, instead\
extending Happen's existing API to work with arrays:\

\fs32\fsmilli16020 Fan-out: One Event, Multiple Nodes\

\fs22\fsmilli11214 // Register a handler across multiple nodes using an array\
[orderNode, paymentNode, inventoryNode].on("update", (event,\
context) => \{\
// Handler receives events from any of these nodes\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 62 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Handler receives events from any of these nodes\
console.log(`Processing update in $\{context.node.id\}`);\
\});\
// Send an event to multiple nodes using an array\
[orderNode, shippingNode, notificationNode].send(\{\
type: "order-completed",\
payload: \{ orderId: "ORD-123" \}\
\});\

\fs32\fsmilli16020 Fan-in: Multiple Events, One Handler\

\fs22\fsmilli11214 // Send multiple events as a batch using an array\
node.send(targetNode, [\
\{ type: "data-point", payload: \{ value: 10 \} \},\
\{ type: "data-point", payload: \{ value: 20 \} \},\
\{ type: "data-point", payload: \{ value: 30 \} \}\
]);\
// Handler naturally works with both individual events and batches\
node.on("data-point", (eventOrEvents, context) => \{\
// Simple array check tells you what you received\
if (Array.isArray(eventOrEvents)) \{\
console.log(`Processing batch of $\{eventOrEvents.length\}\
events`);\
return processBatch(eventOrEvents);\
\} else \{\
console.log(`Processing single event:\
$\{eventOrEvents.payload.value\}`);\
return processSingle(eventOrEvents);\
\}\
\});\

\fs38\fsmilli19224 The Event Continuum and Divergent Flows\

\fs25\fsmilli12816 When an event is sent to multiple nodes using Confluence, each node\
processes it through its own independent flow chain, creating "divergent\
flows" - parallel processing paths that naturally extend the Event Continuum\
model:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 63 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Register with multiple nodes\
[orderNode, inventoryNode, notificationNode].on("order-updated",\
function validateUpdate(event, context) \{\
// This function runs independently for each node\
console.log(`Validating update in $\{context.node.id\}`);\
// Each node can return a different next function\
if (context.node.id === "order-service") \{\
return updateOrderRecord;\
\} else if (context.node.id === "inventory-service") \{\
return updateInventoryLevels;\
\} else \{\
return sendNotifications;\
\}\
\});\
// Node-specific continuation functions\
function updateOrderRecord(event, context) \{\
// Only runs in the order node's flow\
console.log("Updating order records");\
return \{ updated: true \};\
\}\
function updateInventoryLevels(event, context) \{\
// Only runs in the inventory node's flow\
console.log("Updating inventory levels");\
return \{ inventoryUpdated: true \};\
\}\
function sendNotifications(event, context) \{\
// Only runs in the notification node's flow\
console.log("Sending notifications");\
return \{ notificationsSent: true \};\
\}\

\fs25\fsmilli12816 This creates a causal tree structure where:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Each node has its own isolated context\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Flow paths can diverge based on node-specific logic\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Return values are tracked per node\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 The complete causal history is preserved\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 64 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 When you need the results from multiple nodes:\

\fs22\fsmilli11214 // Send to multiple nodes and await results using the standard\
return method\
const results = await sender.send([node1, node2, node3],\
event).return();\
// Results contains node-specific returns in a keyed object\
console.log(`Node1 result: $\{results.node1\}`);\
console.log(`Node2 result: $\{results.node2\}`);\
console.log(`Node3 result: $\{results.node3\}`);\

\fs38\fsmilli19224 No Config Needed\

\fs25\fsmilli12816 Since batching is fully explicit with arrays, there's no magical configuration\
needed. Batches are simply arrays of events that you create and send\
directly:\

\fs22\fsmilli11214 // Send a single event\
node.send(targetNode, \{\
type: "data-point",\
payload: \{ value: 42 \}\
\});\
// Send a batch as an explicit array of events\
node.send(targetNode, [\
\{ type: "data-point", payload: \{ value: 10 \} \},\
\{ type: "data-point", payload: \{ value: 20 \} \},\
\{ type: "data-point", payload: \{ value: 30 \} \}\
]);\

\fs25\fsmilli12816 This direct approach ensures complete predictability with no behind-the-\
scenes magic.\

\fs38\fsmilli19224 Causality Preservation\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 65 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Even with batches and multi-node processing, Confluence maintains\
Happen's causality guarantees:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 The causal context is preserved for each event in a batch\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Each event maintains its position in the causal chain\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Batch processing still records each event's causal history\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Divergent flows are tracked as branches in the causal tree\
This means you can always trace the complete history of events, even when\
they've been processed in batches or across multiple nodes.\

\fs38\fsmilli19224 Context in Multi-Node Operations\

\fs25\fsmilli12816 When working with multiple nodes, context handling is structured to maintain\
node-specific isolation while providing clear access to relevant information:\

\fs32\fsmilli16020 Node-Specific Context Structure\

\fs25\fsmilli12816 When a handler receives an event in a multi-node operation, the context\
structure clearly identifies which node is processing it:\

\fs22\fsmilli11214 [orderNode, inventoryNode, shippingNode].on("order-updated",\
(event, context) => \{\
// The context.node property identifies the specific node\
console.log(`Processing in: $\{context.node.id\}`);\
// Each node maintains its own isolated context\
context.nodeState = context.nodeState || \{\};\
context.nodeState.lastProcessed = Date.now();\
\});\

\fs32\fsmilli16020 Results Collection\

\fs25\fsmilli12816 When collecting results from multiple nodes, the returned object has a clear\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 66 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 structure with node IDs as keys:\

\fs22\fsmilli11214 // Send to multiple nodes and collect results\
const results = await sender.send([orderNode, inventoryNode,\
shippingNode], \{\
type: "verify-order",\
payload: \{ orderId: "ORD-123" \}\
\}).return();\
// Results object is structured by node ID\
console.log(`Order verification:\
$\{results[orderNode.id].verified\}`);\
console.log(`Inventory status:\
$\{results[inventoryNode.id].available\}`);\
console.log(`Shipping estimate:\
$\{results[shippingNode.id].estimatedDays\}`);\

\fs32\fsmilli16020 Batch Context Structure\

\fs25\fsmilli12816 For batch operations (multiple events to a single node), the context provides\
batch-level information at the root, with individual event contexts in an array:\

\fs22\fsmilli11214 node.on("data-point", (events, context) => \{\
if (Array.isArray(events)) \{\
// Batch-level information at the root\
console.log(`Processing batch of $\{events.length\} events`);\
console.log(`Batch received at: $\{context.receivedAt\}`);\
// Each event has its own context in the events array\
events.forEach((event, index) => \{\
// context.events contains the individual event contexts\
const eventContext = context.events[index];\
console.log(`Event $\{index\} causation:\
$\{eventContext.causal.causationId\}`);\
\});\
\}\
\});\

\fs32\fsmilli16020 Combined Multi-Node and Batch Operations\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 67 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 In the rare case of both batching and multi-node operations, the context\
structure maintains clear separation:\

\fs22\fsmilli11214 [nodeA, nodeB].on("process-batch", (eventsOrEvent, context) => \{\
// First determine which node we are\
const nodeId = context.node.id;\
// Then check if we're processing a batch\
if (Array.isArray(eventsOrEvent)) \{\
// We're in a specific node, processing a batch\
console.log(`Node $\{nodeId\} processing batch of\
$\{eventsOrEvent.length\} events`);\
// Access node-specific batch processing logic\
return\
context);\
\} else \{\
nodeProcessingStrategies[nodeId].processBatch(eventsOrEvent,\
// We're in a specific node, processing a single event\
console.log(`Node $\{nodeId\} processing single event`);\
// Access node-specific individual processing logic\
return\
context);\
nodeProcessingStrategies[nodeId].processSingle(eventsOrEvent,\
\}\
\});\

\fs25\fsmilli12816 This context structure ensures that no matter how complex the operation,\
each node maintains its own isolated processing environment while still\
providing clear access to all necessary information.\

\fs38\fsmilli19224 Examples\

\fs32\fsmilli16020 Explicit Batch Creation and Processing\

\fs22\fsmilli11214 // Efficiently handle high-volume sensor data\
const telemetryNode = createNode("telemetry-processor");\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 68 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Explicitly create batches - no magic behind the scenes\
function sendSensorData(readings) \{\
// Create batches of appropriate size\
const batchSize = 50;\
for (let i = 0; i < readings.length; i += batchSize) \{\
// Explicitly create a batch as an array of events\
const batch = readings.slice(i, i + batchSize).map(reading =>\
(\{\
type: "sensor-reading",\
payload: \{\
sensorId: reading.sensorId,\
value: reading.value\
\}\
\}));\
// Send the batch explicitly as an array\
sensorNode.send(telemetryNode, batch);\
\}\
\}\
// Generate some sample readings\
const readings = Array.from(\{ length: 1000 \}, (_, i) => (\{\
sensorId: `sensor-$\{i % 10\}`,\
value: Math.random() * 100\
\}));\
// Send readings in explicit batches\
sendSensorData(readings);\
// Handler processes either single events or explicitly sent\
batches\
telemetryNode.on("sensor-reading", (eventOrEvents, context) => \{\
if (Array.isArray(eventOrEvents)) \{\
// Process an explicitly sent batch\
const readings = eventOrEvents.map(e => e.payload.value);\
const average = readings.reduce((sum, v) => sum + v, 0) /\
readings.length;\
console.log(`Processed batch of $\{eventOrEvents.length\}\
readings, avg: $\{average\}`);\
return \{ processed: readings.length \};\
\} else \{\
// Process single event\
processSingleReading(eventOrEvents.payload);\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 69 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 processSingleReading(eventOrEvents.payload);\
return \{ processed: 1 \};\
\}\
\});\

\fs32\fsmilli16020 Distributed Notification System with Divergent Flows\

\fs22\fsmilli11214 // System monitor that alerts multiple subsystems\
const monitorNode = createNode("system-monitor");\
const alertNode = createNode("alert-service");\
const loggingNode = createNode("logging-service");\
const adminNode = createNode("admin-dashboard");\
// Send critical alerts to multiple services\
function reportCriticalIssue(issue) \{\
[alertNode, loggingNode, adminNode].send(\{\
type: "critical-alert",\
payload: \{\
issue,\
timestamp: Date.now(),\
severity: "critical"\
\}\
\});\
\}\
// Each node processes alerts through its own flow\
[alertNode, loggingNode, adminNode].on("critical-alert", function\
processAlert(event, context) \{\
// Common processing logic\
console.log(`Alert received in $\{context.node.id\}`);\
// Node-specific next step\
if (context.node.id === "alert-service") \{\
return sendUserAlerts;\
\} else if (context.node.id === "logging-service") \{\
return createLogEntry;\
\} else \{\
return updateDashboard;\
\}\
\});\
// Node-specific continuation functions\
function sendUserAlerts(event, context) \{\
// Alert service sends notifications to users\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 70 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Alert service sends notifications to users\
return \{ alertsSent: 10 \};\
\}\
function createLogEntry(event, context) \{\
// Logging service creates permanent record\
return \{ loggedAt: Date.now() \};\
\}\
function updateDashboard(event, context) \{\
// Admin dashboard updates UI\
return \{ dashboardUpdated: true \};\
\}\

\fs32\fsmilli16020 Manual Batch Processing\

\fs22\fsmilli11214 // Explicitly create and send a batch of events\
const orderBatch = [\
\{ type: "process-order", payload: \{ orderId: "ORD-001", total:\
125.00 \} \},\
\{ type: "process-order", payload: \{ orderId: "ORD-002", total:\
75.50 \} \},\
\{ type: "process-order", payload: \{ orderId: "ORD-003", total:\
240.00 \} \}\
];\
// Send the batch\
node.send(processingNode, orderBatch);\
// Handle the batch on the receiving side\
processingNode.on("process-order", (eventOrEvents, context) => \{\
if (Array.isArray(eventOrEvents)) \{\
// Batch processing\
const totalValue = eventOrEvents.reduce((sum, e) => sum +\
e.payload.total, 0);\
return \{ totalProcessed: eventOrEvents.length, totalValue \};\
\} else \{\
// Individual processing\
return \{ processed: eventOrEvents.payload.orderId \};\
\}\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 71 of 234Happen\
7/7/25, 07:52\

\f1\fs38\fsmilli19224 \cf3 Performance Considerations\

\fs25\fsmilli12816 Confluence is designed to be explicit and predictable while still providing\
performance benefits:\

\fs32\fsmilli16020 When to Use Batching\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 High-volume event streams with similar event types\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Processing that benefits from aggregation (like analytics)\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Networks with significant latency where reducing round-trips helps\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Calculations that can be optimized when performed on multiple items\
together\

\fs32\fsmilli16020 When to Use Multi-node Operations\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Broadcast notifications that multiple subsystems need to process\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Commands that affect multiple services simultaneously\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Cross-cutting concerns like logging, monitoring, or security\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Redundant processing for critical operations\

\fs32\fsmilli16020 Batch Processing Efficiency\

\fs25\fsmilli12816 For maximum efficiency when processing batches:\
\cf5 1. \cf3 Use Specialized Algorithms: Many operations are more efficient on\
batches (like bulk database inserts)\
\cf5 2. \cf3 Minimize Per-event Overhead: Amortize setup costs across multiple\
events\
\cf5 3. \cf3 Leverage Memory Locality: Process related data together to improve\
cache efficiency\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 72 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 4. \cf3 Prefer Single Passes: Process the entire batch in one pass rather than\
multiple iterations\

\fs32\fsmilli16020 Memory Management\

\fs25\fsmilli12816 Batch processing can also help with memory efficiency:\

\fs22\fsmilli11214 // Process high-volume data with controlled memory usage\
node.on("high-volume-data", (eventOrEvents, context) => \{\
if (Array.isArray(eventOrEvents)) \{\
// Process incrementally to avoid memory spikes\
let results = [];\
const batchSize = 100;\
for (let i = 0; i < eventOrEvents.length; i += batchSize) \{\
const chunk = eventOrEvents.slice(i, i + batchSize);\
const chunkResults = processChunk(chunk);\
results = results.concat(chunkResults);\
// Allow event loop to run between chunks if needed\
if (i + batchSize < eventOrEvents.length) \{\
yield \{ progress: Math.round((i + batchSize) /\
eventOrEvents.length * 100) \};\
\}\
\}\
return \{ results \};\
\}\
\});\

\fs38\fsmilli19224 Conclusion\

\fs25\fsmilli12816 Confluence provides powerful capabilities for handling multiple events and\
multiple nodes while maintaining Happen's commitment to radical simplicity.\
Through a single intuitive container pattern - using arrays for both nodes and\
events - it enables sophisticated batch processing and multi-node\
communication without introducing special methods or complex APIs.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 73 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 The system offers:\
\cf5 1. \cf3 Pure Symmetry: The same pattern works for both nodes and events\
\cf5 2. \cf3 Explicit Control: No "magic" - batching and multi-node operations are\
explicit\
\cf5 3. \cf3 Divergent Flows: Natural extension of the Event Continuum to parallel\
processing\
\cf5 4. \cf3 Zero New Methods: Works entirely through existing APIs with array\
support\
\cf5 5. \cf3 Powerful Capabilities: Enables sophisticated patterns with minimal\
complexity\
Staying true to Happen's core philosophy of simplicity by recognizing that\
arrays naturally represent collections enables a powerful system with virtually\
no learning curve.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 74 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Dependency Management\

\fs25\fsmilli12816 In line with Happen's philosophy of simplicity, our approach to dependencies\
emphasizes direct runtime access with minimal framework abstractions.\

\fs38\fsmilli19224 Core Principles\

\fs25\fsmilli12816 Happen's dependency management follows three key principles:\
\cf5 1. \cf3 Runtime Transparency: Your code has direct access to the runtime\
environment\
\cf5 2. \cf3 Minimal System Dependencies: Only essential framework dependencies\
(primarily NATS) are injected at initialization\
\cf5 3. \cf3 Event-Based Communication: Nodes interact through events, not\
traditional dependency injection\

\fs38\fsmilli19224 System-Level Dependencies\

\fs25\fsmilli12816 System dependencies are configured once during framework initialization:\

\fs22\fsmilli11214 // Initialize Happen with system-level dependencies\
const happen = initializeHappen(\{\
// NATS configuration as the primary dependency\
nats: \{\
// Direct NATS client for server environments\
server: \{\
servers: ['nats://localhost:4222'],\
jetstream: true\
\},\
// WebSocket client for browser environments\
browser: \{\
servers: ['wss://localhost:8443'],\
jetstream: true\
\}\
\},\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 75 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Optional: Override crypto implementation\
crypto: cryptoImplementation\
\});\
// The initialized framework provides the node creation function\
const \{ createNode \} = happen;\

\fs25\fsmilli12816 These system dependencies represent the minimal set required for Happen to\
function across different runtime environments. By injecting them at\
initialization, we maintain runtime agnosticism while ensuring consistent\
behavior.\

\fs38\fsmilli19224 Direct Runtime Access\

\fs25\fsmilli12816 Rather than exposing a subset of features through abstraction layers, Happen\
encourages direct access to the runtime:\

\fs22\fsmilli11214 // Import runtime capabilities directly\
import \{ WebSocketServer \} from 'ws';\
import * as fs from 'fs';\
const notificationNode = createNode('notification-service');\
// Set up WebSocket server directly using runtime capabilities\
const wss = new WebSocketServer(\{ port: 8080 \});\
const clients = new Map();\
// Use runtime WebSocket events directly\
wss.on('connection', (ws, req) => \{\
const userId = getUserIdFromRequest(req);\
clients.set(userId, ws);\
ws.on('close', () => \{\
clients.delete(userId);\
\});\
\});\
// Process events using the Event Continuum\
notificationNode.on('notify-user', function notifyUser(event,\
context) \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 76 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 context) \{\
const \{ userId, message \} = event.payload;\
// Direct runtime access - no framework abstraction\
const clientSocket = clients.get(userId);\
if (!clientSocket || clientSocket.readyState !== WebSocket.OPEN)\
\{\
return \{\
success: false,\
reason: "user-not-connected"\
\};\
\}\
// Send notification\
clientSocket.send(JSON.stringify(\{\
type: 'notification',\
message\
\}));\
return \{\
success: true,\
delivered: true\
\};\
\});\

\fs25\fsmilli12816 This approach provides several benefits:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Zero overhead: No performance penalty for accessing runtime features\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Full capabilities: Access to everything the runtime offers, not just what the\
framework exposes\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Runtime evolution: Immediate access to new runtime features without\
framework updates\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Ecosystem compatibility: Works seamlessly with the broader ecosystem\

\fs38\fsmilli19224 Framework Agnosticism for Third-Party Libraries\

\fs25\fsmilli12816 When you need external libraries, import and use them directly:\

\fs22\fsmilli11214 // Import NATS client directly - no framework-specific imports\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 77 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Import NATS client directly - no framework-specific imports\
import \{ connect \} from 'nats';\
const databaseNode = createNode('database-service');\
// Use the NATS client directly\
const nc = await connect(\{ servers: 'nats://localhost:4222' \});\
const js = nc.jetstream();\
databaseNode.on('query-users', function queryUsers(event, context)\
\{\
const \{ searchTerm \} = event.payload;\
// Direct use of NATS client with KV store\
const kv = js.keyValue("users");\
const values = [];\
for await (const k of kv.keys()) \{\
if (k.includes(searchTerm)) \{\
const entry = await kv.get(k);\
values.push(JSON.parse(entry.string()));\
\}\
\}\
return \{\
success: true,\
results: values\
\};\
\});\

\fs38\fsmilli19224 Dependency Injection Through Closures\

\fs25\fsmilli12816 Use closures to create handlers with access to dependencies:\

\fs22\fsmilli11214 // Initialize node with dependencies\
function initializeDataNode() \{\
// Create NATS client and JetStream KV store\
const nc = await connect(\{ servers: 'nats://localhost:4222' \});\
const js = nc.jetstream();\
const kv = js.keyValue("data");\
// Create node\
const dataNode = createNode('data-service');\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 78 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 const dataNode = createNode('data-service');\
// Register handler using closure to capture dependencies\
dataNode.on('query-data', (event, context) => \{\
// Use kv from closure scope\
return processQuery(kv, event, context);\
\});\
return dataNode;\
\}\
// Function that uses dependency passed via parameters\
function processQuery(kv, event, context) \{\
const \{ query, params \} = event.payload;\
// Use dependency from parameters\
return new Promise((resolve, reject) => \{\
// Use NATS KV store for data access\
try \{\
const results = [];\
for (const key of query.keys) \{\
const entry = await kv.get(key);\
if (entry) \{\
results.push(JSON.parse(entry.string()));\
\}\
\}\
resolve(\{\
success: true,\
results\
\});\
\} catch (err) \{\
reject(err);\
\}\
\});\
\}\
// Create node\
const dataNode = initializeDataNode();\

\fs38\fsmilli19224 Flow State Through Closures\

\fs25\fsmilli12816 Although Happen provides a common object to share data across each flow\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 79 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 you can also use closures to manage both dependencies and flow state, with\
explicit control over the flow through function returns:\

\fs22\fsmilli11214 function initializeOrderNode() \{\
// Create dependencies including NATS client\
const nc = await connect(\{ servers: 'nats://localhost:4222' \});\
const js = nc.jetstream();\
const orderKV = js.keyValue("orders");\
const emailService = createEmailService();\
// Create node\
const orderNode = createNode('order-service');\
// Register initial handler with dependencies captured in closure\
orderNode.on('process-order', (event, context) => \{\
// Create initial flow state\
const flowState = \{\
orderId: generateOrderId(),\
items: event.payload.items,\
customer: event.payload.customer\
\};\
// Return the first step function with dependencies and state\
in closure\
// This function will be executed next in the flow\
return validateOrder(orderKV, emailService, flowState);\
\});\
return orderNode;\
\}\
// Each flow function creates and returns the next handler in the\
chain\
function validateOrder(orderKV, emailService, state) \{\
// This function is returned by the initial handler and executed\
by the framework\
return (event, context) => \{\
// Validate order\
const validationResult = validateOrderData(state.items);\
if (!validationResult.valid) \{\
// Return a value (not a function) to complete the flow with\
error\
return \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 80 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 return \{\
success: false,\
errors: validationResult.errors\
\};\
\}\
// Update state (immutably)\
const updatedState = \{\
...state,\
validated: true,\
validatedAt: Date.now()\
\};\
// Return the next function to be executed in the flow\
return processPayment(orderKV, emailService, updatedState);\
\};\
\}\
function processPayment(orderKV, emailService, state) \{\
// Return a function that will be executed as the next step\
return (event, context) => \{\
// Process payment asynchronously\
const paymentResult = processCustomerPayment(state.customer,\
calculateTotal(state.items));\
error\
if (!paymentResult.success) \{\
// Return a value (not a function) to complete the flow with\
return \{\
success: false,\
reason: "payment-failed"\
\};\
\}\
// Update state (immutably)\
const updatedState = \{\
...state,\
paymentId: paymentResult.transactionId,\
paymentMethod: paymentResult.method,\
paidAt: Date.now()\
\};\
// Return the next function to be executed in the flow\
return finalizeOrder(orderKV, emailService, updatedState);\
\};\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 81 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 \}\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 function finalizeOrder(orderKV, emailService, state) \{\
// Return a function that will be executed as the next step\
return async (event, context) => \{\
// Create order in KV store\
await orderKV.put(state.orderId, JSON.stringify(\{\
id: state.orderId,\
customer: state.customer,\
items: state.items,\
payment: \{\
id: state.paymentId,\
method: state.paymentMethod\
\}\
\}));\
// Send confirmation email\
emailService.sendOrderConfirmation(\
state.customer.email,\
state.orderId,\
state.items\
);\
// Return a value (not a function) to complete the flow with\
success\
return \{\
success: true,\
orderId: state.orderId,\
transactionId: state.paymentId\
\};\
\};\
\}\

\fs38\fsmilli19224 How Flow Control Works With Closures\

\fs25\fsmilli12816 In this pattern, the flow is controlled through a clear mechanism:\
\cf5 1. \cf3 Each flow step returns a function: When a handler wants to continue the\
flow, it returns a function that becomes the next handler.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 82 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 2. \cf3 Flow continues while functions are returned: The framework executes\
each returned function in sequence, as long as functions are being\
returned.\
\cf5 3. \cf3 Flow ends when a non-function is returned: When a handler returns\
anything other than a function (like an object), the flow completes with\
that value as the result.\
\cf5 4. \cf3 Dependencies and state flow through function parameters: Each step\
receives dependencies and state through its parameters, not through\
context.\
\cf5 5. \cf3 Each step creates the next step with updated state: Functions create and\
return the next function in the chain, passing updated state and\
dependencies.\

\fs38\fsmilli19224 Benefits of Closure-Based Dependency\
Management\

\fs25\fsmilli12816 This closure-based approach offers several advantages:\
\cf5 1. \cf3 Pure Functions: Flow handlers become pure functions with explicit\
dependencies\
\cf5 2. \cf3 Clear Data Flow: Dependencies and state are explicitly passed between\
functions\
\cf5 3. \cf3 Testability: Each flow step can be easily tested in isolation with mocked\
dependencies\
\cf5 4. \cf3 Immutability: Encourages immutable state updates through function\
parameters\
\cf5 5. \cf3 Separation of Concerns: Clearly separates framework concerns from\
application logic\

\fs38\fsmilli19224 NATS as the Primary Dependency\

\fs25\fsmilli12816 In the Happen framework, NATS serves as the primary dependency, providing\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 83 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 core messaging, persistence, and coordination capabilities. This focused\
approach means:\
\cf5 1. \cf3 Single Core Dependency: NATS is the primary external dependency you\
need to understand\
\cf5 2. \cf3 Mature Ecosystem: NATS has clients for all major languages and\
platforms\
\cf5 3. \cf3 Unified Capability Set: One system provides messaging, persistence, and\
coordination\
\cf5 4. \cf3 Direct NATS Access: Your code can access NATS capabilities directly\
when needed\

\fs38\fsmilli19224 Dependency Management Philosophy\

\fs25\fsmilli12816 Happen's approach to dependencies reflects its broader philosophy: provide\
just enough framework to enable powerful capabilities, while getting out of\
the way and letting your code work directly with the runtime.\
By limiting injected dependencies to only essential system needs (primarily\
NATS) and embracing direct runtime access and closure-based dependency\
management, Happen reduces complexity while maximizing flexibility.\
There's no complex dependency injection system because, in most cases,\
you simply use JavaScript's natural closure mechanism to capture and pass\
dependencies where needed.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 84 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Closures, A Primer\

\fs25\fsmilli12816 Closures are a fundamental concept in JavaScript that provide an elegant\
solution for managing state and dependencies in event-driven systems like\
Happen. This primer will help you understand what closures are, how they\
work, and how they enable powerful patterns in your applications.\

\fs38\fsmilli19224 What is a Closure?\

\fs25\fsmilli12816 A closure is a function that "remembers" the environment in which it was\
created. More specifically, a closure is formed when a function retains access\
to variables from its outer (enclosing) scope, even after that outer function\
has completed execution.\

\fs22\fsmilli11214 function createGreeter(greeting) \{\
// The inner function is a closure that "captures" the greeting\
variable\
return function(name) \{\
return `$\{greeting\}, $\{name\}!`;\
\};\
\}\
// Create closures with different captured values\
const sayHello = createGreeter("Hello");\
const sayHi = createGreeter("Hi");\
// Use the closures\
console.log(sayHello("Alice")); // "Hello, Alice!"\
console.log(sayHi("Bob")); // "Hi, Bob!"\

\fs25\fsmilli12816 In this example, 
\fs22\fsmilli11214 createGreeter 
\fs25\fsmilli12816 returns a function that "closes over" the\

\fs22\fsmilli11214 greeting 
\fs25\fsmilli12816 parameter. Each returned function remembers its own specific\
greeting, even after 
\fs22\fsmilli11214 createGreeter 
\fs25\fsmilli12816 has finished executing.\

\fs38\fsmilli19224 How Closures Work\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 85 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 To understand closures, you need to understand two key JavaScript\
concepts: lexical scope and the function execution context.\

\fs32\fsmilli16020 Lexical Scope\

\fs25\fsmilli12816 JavaScript uses lexical scoping, which means that functions are executed in\
the scope where they were defined, not where they are called:\

\fs22\fsmilli11214 function outer() \{\
const message = "Hello from outer scope!";\
function inner() \{\
console.log(message); // Accesses variable from outer scope\
\}\
inner();\
\}\
outer(); // "Hello from outer scope!"\

\fs32\fsmilli16020 Execution Context and Environment\

\fs25\fsmilli12816 When a function is created, it stores a reference to its lexical environment\'97\
the set of variables and their values that were in scope when the function was\
created. This environment reference stays with the function, even if the\
function is returned or passed elsewhere.\

\fs22\fsmilli11214 function createCounter() \{\
let count = 0; // Private state variable\
return \{\
increment: function() \{\
count++; // Accesses the count variable from the outer scope\
return count;\
\},\
decrement: function() \{\
count--; // Also accesses the same count variable\
return count;\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 86 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 getCount: function() \{\
return count;\
\},\
\}\
\};\
\}\
const counter = createCounter();\
console.log(counter.increment()); // 1\
console.log(counter.increment()); // 2\
console.log(counter.decrement()); // 1\
console.log(counter.getCount()); // 1\

\fs25\fsmilli12816 In this example, all three functions share access to the same 
\fs22\fsmilli11214 count 
\fs25\fsmilli12816 creating a private state that can't be accessed directly from outside.\
variable,\

\fs38\fsmilli19224 Memory Management and Garbage Collection\

\fs25\fsmilli12816 Understanding how closures affect memory management is important for\
building efficient applications:\
\cf5 1. \cf3 Retained References: When a function forms a closure, the JavaScript\
engine keeps all captured variables in memory as long as the function\
itself is reachable.\
\cf5 2. \cf3 Selective Retention: The engine is smart enough to only retain variables\
that are actually referenced in the closure, not the entire scope.\
\cf5 3. \cf3 Potential Memory Leaks: Closures can lead to memory leaks if you\
inadvertently keep references to large objects that are no longer needed.\
\cf5 4. \cf3 Automatic Cleanup: When no references to a closure remain, both the\
closure and its environment will be garbage collected.\

\fs22\fsmilli11214 function potentialLeak() \{\
// Large data structure\
const hugeData = new Array(1000000).fill("data");\
// This closure references hugeData\
function processingFunction() \{\
return hugeData.length;\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 87 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 return hugeData.length;\
\}\
// This closure doesn't reference hugeData\
function safeFunction() \{\
return "Safe result";\
\}\
// processingFunction retains hugeData in memory\
// safeFunction doesn't retain hugeData\
return \{\
withReference: processingFunction,\
withoutReference: safeFunction\
\};\
\}\
const result = potentialLeak();\
// hugeData is still in memory because processingFunction\
references it\

\fs25\fsmilli12816 To avoid memory leaks, it's good practice to:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Only capture what you need in closures\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Set captured references to null when you're done with them\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Be mindful of large objects in closure scope\

\fs38\fsmilli19224 Practical Uses of Closures\

\fs25\fsmilli12816 Closures enable several powerful programming patterns:\

\fs32\fsmilli16020 1. Data Encapsulation and Privacy\

\fs25\fsmilli12816 Closures provide a way to create private variables that can't be accessed\
directly from outside:\

\fs22\fsmilli11214 function createUser(name, initialBalance) \{\
// Private variables\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 88 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Private variables\
let userName = name;\
let balance = initialBalance;\
return \{\
getName: () => userName,\
getBalance: () => balance,\
deposit: amount => \{\
balance += amount;\
return balance;\
\},\
withdraw: amount => \{\
if (amount <= balance) \{\
balance -= amount;\
return balance;\
\}\
return "Insufficient funds";\
\}\
\};\
\}\
const user = createUser("Alice", 100);\
console.log(user.getBalance()); // 100\
user.deposit(50);\
console.log(user.getBalance()); // 150\
// Cannot access balance directly\
console.log(user.balance); // undefined\

\fs32\fsmilli16020 2. Function Factories\

\fs25\fsmilli12816 Closures allow you to create specialized functions based on parameters:\

\fs22\fsmilli11214 function createValidator(validationFn, errorMessage) \{\
return function(value) \{\
if (!validationFn(value)) \{\
return \{ valid: false, error: errorMessage \};\
\}\
return \{ valid: true \};\
\};\
\}\
const validateEmail = createValidator(\
email => /^[^@]+@[^@]+\\.[^@]+$/.test(email),\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 89 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 "Invalid email format"\
);\
const validatePassword = createValidator(\
password => password.length >= 8,\
"Password must be at least 8 characters"\
);\
console.log(validateEmail("user@example.com")); // \{ valid: true \}\
console.log(validatePassword("123")); // \{ valid: false,\
error: "Password must be at least 8 characters" \}\

\fs32\fsmilli16020 3. Maintaining State in Async Operations\

\fs25\fsmilli12816 Closures are invaluable for preserving state across asynchronous operations:\

\fs22\fsmilli11214 function processUserData(userId) \{\
// State captured in closure\
const processingStart = Date.now();\
const metrics = \{ steps: 0 \};\
// Get user data\
fetchUser(userId).then(userData => \{\
metrics.steps++;\
// Process user preferences\
return\
fetchPreferences(userData.preferencesId).then(preferences => \{\
metrics.steps++;\
// Combine data\
const result = \{\
user: userData,\
preferences: preferences,\
processingTime: Date.now() - processingStart,\
processingSteps: metrics.steps\
\};\
// All async operations have access to the same captured\
state\
displayResults(result);\
\});\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 90 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \});\
\}\

\fs32\fsmilli16020 4. Event Handlers with Preset Data\

\fs25\fsmilli12816 Closures are perfect for creating event handlers that include specific data:\

\fs22\fsmilli11214 function setupButtonHandlers(buttons) \{\
buttons.forEach(button => \{\
// Each handler is a closure with its own reference to the\
specific button\
button.addEventListener('click', () => \{\
console.log(`Button $\{button.id\} was clicked`);\
processButtonAction(button.dataset.action);\
\});\
\});\
\}\

\fs38\fsmilli19224 Closures in Happen's Event Continuum\

\fs25\fsmilli12816 In Happen, closures provide an elegant solution for managing dependencies\
and state across event flows:\

\fs22\fsmilli11214 function setupOrderProcessing(orderRepository, emailService) \{\
const orderNode = createNode('order-service');\
orderNode.on('process-order', event => \{\
// Initialize flow state\
const state = \{\
orderId: generateOrderId(),\
items: event.payload.items,\
customer: event.payload.customer\
\};\
// Return first step with dependencies and state in closure\
return validateOrder(orderRepository, emailService, state);\
\});\
return orderNode;\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 91 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 return orderNode;\
\}\
function validateOrder(repository, emailService, state) \{\
// Return a handler function that has captured dependencies and\
state\
return (event, context) => \{\
// Validate using captured state\
const validationResult = validateItems(state.items);\
if (!validationResult.valid) \{\
return \{ success: false, errors: validationResult.errors \};\
\}\
// Update state immutably\
const updatedState = \{\
...state,\
validatedAt: Date.now()\
\};\
// Return next step with updated state\
return processPayment(repository, emailService, updatedState);\
\};\
\}\

\fs25\fsmilli12816 This pattern provides several benefits:\
\cf5 1. \cf3 Explicit Dependency Injection: Dependencies are passed explicitly rather\
than through global state\
\cf5 2. \cf3 Immutable State Flow: State changes are explicit and traceable\
\cf5 3. \cf3 Testable Units: Each step can be tested independently with mocked\
dependencies\
\cf5 4. \cf3 Freedom from Context: No need to rely on the event context for state\

\fs38\fsmilli19224 Best Practices for Closures\

\fs25\fsmilli12816 To use closures effectively:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 92 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 1. \cf3 Keep closures focused: Capture only what you need to minimize memory\
usage.\
\cf5 2. \cf3 Use immutable patterns: Update state by creating new objects rather than\
mutating existing ones.\
\cf5 3. \cf3 Be mindful of 
\fs22\fsmilli11214 this 
\fs25\fsmilli12816 : Arrow functions capture the lexical 
\fs22\fsmilli11214 this 
\fs25\fsmilli12816 , while\
regular functions have their own 
\fs22\fsmilli11214 this 
\fs25\fsmilli12816 context.\
\cf5 4. \cf3 Watch for circular references: These can prevent garbage collection.\
\cf5 5. \cf3 Prefer pure functions: Closures that don't modify external state are easier\
to reason about.\
\cf5 6. \cf3 Consider performance: For extremely hot code paths, be aware that\
closures have a small overhead compared to direct function calls.\
By understanding and leveraging closures effectively, you can create elegant,\
maintainable code that naturally manages dependencies and state throughout\
your Happen applications.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 93 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 The Information System:\
State, Context, and Views\

\fs25\fsmilli12816 In Happen, information flows naturally through the system in multiple\
complementary forms. The Information System builds on our core primitives\'97\
Nodes and Events\'97while providing powerful capabilities for managing,\
accessing, and transforming information across your application. This\
document explains the conceptual model and practical implementation of\
state, context, and views in Happen.\
The Information System is built on three fundamental concepts:\

\fs32\fsmilli16020 State: What You Own\

\fs25\fsmilli12816 State is information that a node has authority over. It's the internal data that\
the node manages, updates, and is responsible for. State represents "what\
you know and control" within your domain.\
State in Happen is:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Authoritative - The owning node is the single source of truth\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Persisted - State can be saved and restored\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Encapsulated - Direct modification is restricted to the owning node\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Verifiable - State changes are tracked in the causal chain\

\fs22\fsmilli11214 // Basic state access\
const orderNode = createNode("order-service");\
// Read state directly\
const state = orderNode.state.get();\
const pendingOrders = Object.values(state.orders || \{\})\
.filter(order => order.status === "pending");\
// Transform state using a function approach\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 94 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 // Transform state using a function approach\
orderNode.state.set(state => \{\
return \{\
...state,\
orders: \{\
...state.orders,\
"order-123": \{\
customerId: "cust-456",\
items: [\{productId: "prod-789", quantity: 2\}],\
status: "pending"\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \}\
\}\
\};\
\});\

\fs25\fsmilli12816 State can also be accessed selectively, using transformations to extract only\
the required data:\

\fs22\fsmilli11214 // Focused state access\
const activeOrderCount = orderNode.state.get(state =>\
Object.values(state.orders || \{\})\
.filter(order => order.status === "active")\
.length\
);\

\fs32\fsmilli16020 Global State Implementation\

\fs25\fsmilli12816 Happen's provides system-wide, crossboundary global state for universal\
data access throughout the unified event space. Global state is implemented\
using NATS Key-Value store and is accessible from all environments:\
\cf5 1. \cf3 Unified Access: All nodes use the same 
\fs22\fsmilli11214 node.global 
\fs25\fsmilli12816 API regardless of\
environment\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 95 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 2. \cf3 Native Transport Adapters: NATS provides native support for various\
transports:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 TCP for server-to-server communication\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 WebSocket for browser and edge clients\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 TLS/WSS for secure communication\
\cf5 3. \cf3 Consistent Experience: The same operations work identically across all\
environments\
This approach leverages NATS' built-in transport capabilities to provide a\
seamless global state experience without requiring custom protocol\
adaptations.\
For example, storing and retrieving data works the same way everywhere:\

\fs22\fsmilli11214 // Store data in global state\
await node.global.set('user:profile:123', userProfile);\
// Retrieve data from global state\
const profile = await node.global.get('user:profile:123');\

\fs32\fsmilli16020 Context: What Happened and Why\

\fs25\fsmilli12816 Context is information that flows with events, providing essential metadata\
about causality, origin, and relationships. Context represents the "why" and\
"how" of information flow in the system.\
Context in Happen is:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Causal - Tracks relationships between events\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Automatic - Flows naturally with events\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Enriched - Gains additional information as it flows\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Structured - Organized into specific categories\

\fs22\fsmilli11214 // Event with context\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 96 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 // Event with context\
orderNode.broadcast(\{\
type: "order-created",\
payload: \{\
orderId: "ORD-123",\
items: [\{ productId: "PROD-456", quantity: 2 \}]\
\}\
// Context is automatically managed by the framework\
// context: \{\
// causal: \{\
// id: "evt-789", // Unique identifier\
// sender: "order-service", // Origin node\
// causationId: "evt-456", // Direct cause\
// correlationId: "order-123", // Transaction identifier\
// path: ["customer-node", "order-service"] // Event path\
// \},\
// system: \{\
// environment: "production",\
// region: "us-west"\
// \},\
// user: \{\
// id: "user-123",\
// permissions: ["create-order"]\
// \}\
// \}\
\});\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Context is system-managed and automatically flows with events, requiring no\
manual manipulation.\

\fs32\fsmilli16020 Views: Windows Into Other Nodes\

\fs25\fsmilli12816 Views in Happen provide a window into other nodes' state, enabling\
coordinated operations across node boundaries. While conceptually simple,\
views are implemented using an elegant recursive traversal approach that\
leverages JavaScript's reference passing.\
The Recursive Reference Collection Mechanism\
At the core of Happen's view implementation is a recursive traversal of the\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 97 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 node graph, combined with a shared reference mechanism.\
When a node accesses a view, the system:\
\cf5 1. \cf3 Creates a shared reference container (typically an object or array)\
\cf5 2. \cf3 Passes this container to the target node\
\cf5 3. \cf3 The target node deposits its state into the container\
\cf5 4. \cf3 The original node can then access this state through the container\
This mechanism provides several key advantages:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Performance: No need to copy large state objects\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Freshness: Always gets the latest state when accessed\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Simplicity: Minimal API surface for powerful functionality\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Consistency: Predictable access patterns across different node types\
Basic View Usage\

\fs22\fsmilli11214 // Transform state with views into other nodes' state\
orderNode.state.set((state, views) => \{\
// Access customer data through views\
const customerData = views.customer.get(state =>\
state.customers[order.customerId]\
);\
// Access inventory data through views\
const inventoryData = views.inventory.get(state =>\
state.products[order.productId]\
);\
// Return updated state that incorporates external data\
return \{\
...state,\
orders: \{\
...state.orders,\
[order.id]: \{\
...order,\
canShip: inventoryData.inStock,\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 98 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 shippingAddress: customerData.address\
\}\
\}\
\};\
\});\

\fs25\fsmilli12816 Enhanced View Collection\
For more efficient collection of state from multiple nodes in a single operation,\
Happen provides an enhanced collection capability:\

\fs22\fsmilli11214 orderNode.state.set((state, views) => \{\
// Collect state from multiple nodes in a single operation\
const data = views.collect(\{\
customer: state => (\{\
name: state.customers[order.customerId].name,\
address: state.customers[order.customerId].address\
\}),\
inventory: state => (\{\
inStock: state.products[order.productId].quantity > 0,\
leadTime: state.products[order.productId].leadTime\
\}),\
shipping: state => (\{\
rates: state.ratesByRegion[customerRegion],\
methods: state.availableMethods\
\})\
\});\
// Use the collected data\
return \{\
...state,\
orders: \{\
...state.orders,\
[order.id]: \{\
...order,\
fulfillmentPlan: createFulfillmentPlan(data)\
\}\
\}\
\};\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 99 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 This approach:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Traverses the node graph only once\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Collects specific slices of state from each relevant node\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Transforms the state during collection\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Returns a unified object with all the collected data\
For more advanced view patterns and usage, see the dedicated \cf4 State\
Management \cf3 page.\

\fs38\fsmilli19224 The Unified Information System\

\fs25\fsmilli12816 These three concepts\'97State, Context, and Views\'97form a unified information\
model:\
\cf5 1. \cf3 State represents what a node owns and controls\
\cf5 2. \cf3 Context represents the causal flow of information through events\
\cf5 3. \cf3 Views represent windows into state owned by others\
Each serves a distinct purpose in the system, creating a complete information\
model without redundancy or overlap.\

\fs38\fsmilli19224 How These Systems Work Together\

\fs25\fsmilli12816 The power of Happen's information system comes from how these\
complementary systems work together:\

\fs32\fsmilli16020 Context + Views\

\fs25\fsmilli12816 Context and views work together to provide a complete picture of system\
behavior:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 100 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Both context and views working together\
orderNode.on("payment-received", event => \{\
const \{ orderId, amount \} = event.payload;\
const \{ correlationId \} = event.context.causal;\
// Update order with view-aware state transformation\
orderNode.state.set((state, views) => \{\
// Get the current order\
const currentOrder = state.orders[orderId];\
// Collect payment information through enhanced views\
const paymentData = views.collect(\{\
payments: state => (\{\
details: state[event.payload.paymentId],\
methods: state.methods\
\})\
\});\
// Return updated state\
return \{\
...state,\
orders: \{\
...state.orders,\
[orderId]: \{\
...currentOrder,\
status: "paid",\
paymentId: event.payload.paymentId,\
paymentMethod: paymentData.payments.details.method,\
transactionId:\
paymentData.payments.details.transactionId,\
correlationId: correlationId, // From context\
paymentTimestamp: Date.now()\
\}\
\}\
\};\
\});\
// Emit event with proper context\
orderNode.broadcast(\{\
type: "order-paid",\
payload: \{\
orderId,\
amount\
\}\
// Context is automatically managed by the framework\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 101 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Context is automatically managed by the framework\
\});\
\});\

\fs32\fsmilli16020 State + Context = Causal State History\

\fs25\fsmilli12816 The combination of state and context enables rich causal state history:\

\fs22\fsmilli11214 // State history using context\
function getStateHistory(nodeId, statePath) \{\
// Get all events that affected this state path\
const events = eventStore.getEventsForPath(nodeId, statePath);\
// Sort by causal order using context information\
const sortedEvents = sortByCausalOrder(events);\
// Reconstruct state history\
let state = undefined;\
const history = [];\
for (const event of sortedEvents) \{\
state = applyEvent(state, event);\
history.push(\{\
state: \{ ...state \},\
event: event.type,\
timestamp: event.metadata.timestamp,\
causedBy: event.context.causal.causationId,\
by: event.context.causal.sender\
\});\
\}\
return history;\
\}\

\fs32\fsmilli16020 State + Views = System-Wide View\

\fs25\fsmilli12816 The combination of state and views provides a system-wide view:\

\fs22\fsmilli11214 // System-wide view using state and views\
dashboardNode.on("generate-dashboard", event => \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 102 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Use view-aware state transformation to gather system-wide data\
dashboardNode.state.set((state, views) => \{\
// Collect data from various services through enhanced views\
const systemData = views.collect(\{\
orders: state => (\{\
pending: Object.values(state).filter(o => o.status ===\
"pending").length,\
completed: Object.values(state).filter(o => o.status ===\
"completed").length,\
failed: Object.values(state).filter(o => o.status ===\
"failed").length\
\}),\
inventory: state => (\{\
lowStock: Object.values(state.products).filter(p => p.stock\
< 10).length,\
outOfStock: Object.values(state.products).filter(p =>\
p.stock === 0).length\
\}),\
customers: state => (\{\
active: Object.values(state).filter(c => c.active).length,\
new: Object.values(state).filter(c => \{\
const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);\
return c.createdAt >= oneDayAgo;\
\}).length\
\}),\
payments: state => (\{\
daily: Object.values(state)\
.filter(p => p.timestamp >= Date.now() - (24 * 60 * 60 *\
1000))\
.reduce((sum, p) => sum + p.amount, 0),\
weekly: Object.values(state)\
.filter(p => p.timestamp >= Date.now() - (7 * 24 * 60 *\
60 * 1000))\
.reduce((sum, p) => sum + p.amount, 0)\
\})\
\});\
// Return updated dashboard state\
return \{\
...state,\
dashboard: systemData\
\};\
\});\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 103 of 234Happen\
7/7/25, 07:52\

\f1\fs38\fsmilli19224 \cf3 Practical Example: Coordinated Operations\

\fs25\fsmilli12816 Here's a complete example showing how views enable coordinated operations\
across node boundaries:\

\fs22\fsmilli11214 // Order fulfillment process using views\
fulfillmentNode.on('fulfill-order', (event) => \{\
const \{ orderId \} = event.payload;\
// Update fulfillment state based on views of other nodes\
fulfillmentNode.state.set((state, views) => \{\
// Collect data from multiple services in one operation\
const fulfillmentData = views.collect(\{\
orders: state => \{\
const order = state[orderId];\
return order ? \{ order \} : null;\
\},\
inventory: state => (\{\
products: state.products\
\}),\
customers: state => \{\
// We need the order first to get the customerId\
const order = views.orders.get(s => s[orderId]);\
if (!order) return null;\
return \{\
customer: state.customers[order.customerId]\
\};\
\},\
shipping: state => (\{\
rates: state.rates\
\})\
\});\
// Check if order exists\
if (!fulfillmentData.orders) \{\
return state; // No change\
\}\
const order = fulfillmentData.orders.order;\
const customer = fulfillmentData.customers?.customer;\
if (!customer) \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 104 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 if (!customer) \{\
return state; // No change, customer not found\
\}\
// Check inventory availability\
const itemsAvailable = order.items.every(item => \{\
const product =\
fulfillmentData.inventory.products[item.productId];\
return product && product.stock >= item.quantity;\
\});\
if (!itemsAvailable) \{\
return state; // No change, items not available\
\}\
// Get shipping option\
const shippingOption =\
fulfillmentData.shipping.rates[customer.region].standard;\
// Return updated fulfillment state\
return \{\
...state,\
fulfillments: \{\
...state.fulfillments,\
[orderId]: \{\
orderId,\
items: order.items,\
customer: \{\
id: order.customerId,\
name: customer.name,\
address: customer.address\
\},\
shippingMethod: shippingOption.method,\
shippingCost: shippingOption.cost,\
estimatedDelivery: calculateDelivery(customer.address,\
shippingOption),\
status: "ready",\
createdAt: Date.now()\
\}\
\}\
\};\
\});\
// Check if fulfillment was created\
const fulfillment = fulfillmentNode.state.get(state =>\
state.fulfillments?.[orderId]\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 105 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 state.fulfillments?.[orderId]\
);\
if (!fulfillment) \{\
return \{\
success: false,\
reason: "Could not create fulfillment"\
\};\
\}\
// Continue to next step\
return initiateShipment;\
\});\

\fs25\fsmilli12816 The Information System provides a complete model for managing, accessing,\
and transforming information through three complementary concepts:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 State: What nodes own and control\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Context: The causal flow of information through events\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Views: Windows into state owned by others\
Each plays a distinct role, working together to create a powerful yet\
conceptually clean information model:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 State provides ownership and authority\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Context provides causality and correlation\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Views provide access and visibility\
With enhanced view collection capabilities, the Information System enables\
complex, coordinated operations across node boundaries while maintaining\
clean separation of concerns and adhering to Happen's philosophy of radical\
simplicity.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 106 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 State Management\

\fs25\fsmilli12816 State management in Happen provides powerful capabilities through minimal\
abstractions. This guide explores patterns and approaches for effectively\
managing state across your Happen applications.\

\fs38\fsmilli19224 Core Principles\

\fs25\fsmilli12816 Happen's approach to state management follows these foundational\
principles:\
\cf5 1. \cf3 Clear Ownership: Each node owns and is responsible for its specific state\
\cf5 2. \cf3 Functional Transformations: State changes occur through pure functional\
transformations\
\cf5 3. \cf3 Event-Driven Updates: State typically changes in response to events\
\cf5 4. \cf3 Decentralized Intelligence: Nodes make autonomous decisions based on\
their local state\
\cf5 5. \cf3 Composition Over Complexity: Complex state management emerges from\
composing simple patterns\
Under the hood, Happen uses NATS JetStream's Key-Value store to provide\
durable, distributed state storage with high consistency guarantees.\

\fs38\fsmilli19224 Basic State Operations\

\fs32\fsmilli16020 Accessing State\

\fs25\fsmilli12816 Happen provides a clean, functional approach to accessing state:\

\fs22\fsmilli11214 // Access the complete state\
const orderState = orderNode.state.get();\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 107 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Access with transformation (focused state access)\
const activeOrders = orderNode.state.get(state =>\
(state.orders || \{\}).filter(order => order.status === "active")\
);\

\fs32\fsmilli16020 Transforming State\

\fs25\fsmilli12816 State transformations use a functional approach:\

\fs22\fsmilli11214 // Transform state with a function\
orderNode.state.set(state => \{\
return \{\
...state,\
orders: \{\
...state.orders,\
"order-123": \{\
...state.orders["order-123"],\
status: "shipped",\
shippedAt: Date.now()\
\}\
\}\
\};\
\});\

\fs32\fsmilli16020 Composing Transformations\

\fs25\fsmilli12816 You can compose transformations for cleaner code:\

\fs22\fsmilli11214 // Define reusable transformers\
const markShipped = (orderId) => (state) => (\{\
...state,\
orders: \{\
...state.orders,\
[orderId]: \{\
...state.orders[orderId],\
status: "shipped",\
shippedAt: Date.now()\
\}\
\}\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 108 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \});\
// Apply transformer\
orderNode.state.set(markShipped("order-123"));\

\fs38\fsmilli19224 View System\

\fs25\fsmilli12816 Views provide a window into other nodes' state, enabling coordinated\
operations across node boundaries.\

\fs32\fsmilli16020 Basic View Usage\

\fs22\fsmilli11214 // Transform state with views into other nodes' state\
orderNode.state.set((state, views) => \{\
// Get customer data through views\
const customerData = views.customer.get(state =>\
state.customers[order.customerId]\
);\
// Get inventory data through views\
const inventoryData = views.inventory.get(state =>\
state.products[order.productId]\
);\
// Return updated state that incorporates external data\
return \{\
...state,\
orders: \{\
...state.orders,\
[order.id]: \{\
...order,\
canShip: inventoryData.inStock,\
shippingAddress: customerData.address\
\}\
\}\
\};\
\});\

\fs32\fsmilli16020 Enhanced Collection\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 109 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 For more efficient collection of state from multiple nodes, use the collect\
pattern:\

\fs22\fsmilli11214 orderNode.state.set((state, views) => \{\
// Collect state from multiple nodes in a single operation\
const data = views.collect(\{\
customer: state => (\{\
name: state.customers[order.customerId].name,\
address: state.customers[order.customerId].address\
\}),\
inventory: state => (\{\
inStock: state.products[order.productId].quantity > 0,\
leadTime: state.products[order.productId].leadTime\
\}),\
shipping: state => (\{\
rates: state.ratesByRegion[customerRegion],\
methods: state.availableMethods\
\})\
\});\
// Use the collected data\
return \{\
...state,\
orders: \{\
...state.orders,\
[order.id]: \{\
...order,\
fulfillmentPlan: createFulfillmentPlan(data)\
\}\
\}\
\};\
\});\

\fs25\fsmilli12816 This approach:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Traverses the node graph only once\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Collects specific slices of state from each relevant node\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Transforms the state during collection\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Returns a unified object with all the collected data\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 110 of 234Happen\
7/7/25, 07:52\

\f1\fs38\fsmilli19224 \cf3 Scaling Patterns\

\fs25\fsmilli12816 As your application grows, these patterns help manage increasing state\
complexity.\

\fs32\fsmilli16020 Selective State Access\

\fs25\fsmilli12816 Access only what you need to minimize memory footprint:\

\fs22\fsmilli11214 // Instead of loading the entire state\
const allOrders = orderNode.state.get();\
// Access only what you need\
const orderCount = orderNode.state.get(state =>\
Object.keys(state.orders || \{\}).length\
);\

\fs32\fsmilli16020 Domain Partitioning\

\fs25\fsmilli12816 Partition state across multiple domain-specific nodes:\

\fs22\fsmilli11214 // Instead of one large node with all state\
const monolithNode = createNode("monolith");\
// Create domain-specific nodes\
const orderNode = createNode("order-service");\
const customerNode = createNode("customer-service");\
const inventoryNode = createNode("inventory-service");\

\fs25\fsmilli12816 Each node maintains state for its specific domain, communicating via events\
when necessary.\

\fs32\fsmilli16020 Event-Driven State Synchronization\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 111 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Use events to communicate state changes between nodes:\

\fs22\fsmilli11214 // When state changes, broadcast an event\
orderNode.on("update-order", event => \{\
// Update local state\
orderNode.state.set(state => (\{\
...state,\
orders: \{\
...state.orders,\
[event.payload.orderId]: event.payload\
\}\
\}));\
// Broadcast change event\
orderNode.broadcast(\{\
type: "order-updated",\
payload: \{\
orderId: event.payload.orderId,\
status: event.payload.status\
\}\
\});\
\});\
// Other nodes maintain caches of relevant order data\
dashboardNode.on("order-updated", event => \{\
// Update local cache\
dashboardNode.state.set(state => (\{\
...state,\
orderCache: \{\
...state.orderCache,\
[event.payload.orderId]: \{\
status: event.payload.status,\
updatedAt: Date.now()\
\}\
\}\
\}));\
\});\

\fs32\fsmilli16020 Chunked Processing\

\fs25\fsmilli12816 For large state objects, process in manageable chunks:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 112 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 orderNode.on("process-large-dataset", async function* (event) \{\
const \{ dataset \} = event.payload;\
// Process in chunks\
for (let i = 0; i < dataset.length; i += 100) \{\
const chunk = dataset.slice(i, i + 100);\
// Process this chunk\
for (const item of chunk) \{\
processItem(item);\
\}\
// Yield progress\
yield \{\
progress: Math.round((i + chunk.length) / dataset.length *\
100),\
processed: i + chunk.length\
\};\
\}\
return \{ completed: true \};\
\});\

\fs38\fsmilli19224 Advanced Patterns\

\fs32\fsmilli16020 State Versioning\

\fs25\fsmilli12816 Track state versions for debugging and auditing:\

\fs22\fsmilli11214 // Modify state with version tracking\
orderNode.state.set(state => \{\
const newVersion = (state.version || 0) + 1;\
return \{\
...state,\
version: newVersion,\
orders: \{\
...state.orders,\
"order-123": \{\
...state.orders["order-123"],\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 113 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 ...state.orders["order-123"],\
status: "processing",\
updatedAt: Date.now(),\
version: newVersion\
\}\
\}\
\};\
\});\

\fs32\fsmilli16020 Computed State\

\fs25\fsmilli12816 Define computed values based on raw state:\

\fs22\fsmilli11214 orderNode.state.set((state, views) => \{\
// Compute derived values\
const orderSummary = Object.values(state.orders ||\
\{\}).reduce((summary, order) => \{\
summary.total += order.total;\
summary.count += 1;\
summary[order.status] = (summary[order.status] || 0) + 1;\
return summary;\
\}, \{ total: 0, count: 0 \});\
// Return state with computed values\
return \{\
...state,\
computed: \{\
...state.computed,\
orderSummary,\
averageOrderValue: orderSummary.count > 0 ?\
orderSummary.total / orderSummary.count : 0\
\}\
\};\
\});\

\fs32\fsmilli16020 State-Based Event Generation\

\fs25\fsmilli12816 Generate events based on state conditions:\

\fs22\fsmilli11214 orderNode.state.set((state, views) => \{\
// Update order state\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 114 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Update order state\
const updatedState = \{\
...state,\
orders: \{\
...state.orders,\
"order-123": \{\
...state.orders["order-123"],\
status: "payment-received"\
\}\
\}\
\};\
// Check conditions\
const order = updatedState.orders["order-123"];\
const inventory = views.inventory.get(state =>\
state.products[order.productId]\
);\
// Emit events based on state conditions\
if (order.status === "payment-received" && inventory.inStock) \{\
orderNode.broadcast(\{\
type: "order-ready-for-fulfillment",\
payload: \{ orderId: "order-123" \}\
\});\
\}\
return updatedState;\
\});\

\fs38\fsmilli19224 NATS JetStream Key-Value Store Integration\

\fs25\fsmilli12816 Under the hood, Happen uses NATS JetStream's Key-Value store capability to\
provide durable, distributed state storage. The framework handles all the\
details of storing and retrieving state, ensuring:\
\cf5 1. \cf3 Persistence: State is preserved even if nodes or processes restart\
\cf5 2. \cf3 Distributed Access: State can be accessed across different processes\
and machines\
\cf5 3. \cf3 Consistency: State updates maintain causal ordering\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 115 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 4. \cf3 Performance: High-performance storage with minimal overhead\
This integration happens transparently - your code uses the same state API\
regardless of where nodes are running or how state is stored.\

\fs38\fsmilli19224 Best Practices\

\fs32\fsmilli16020 Keep State Focused\

\fs25\fsmilli12816 Each node should maintain state relevant to its domain:\

\fs22\fsmilli11214 // Too broad - mixing domains\
const monolithNode = createNode("app");\
monolithNode.state.set(\{\
orders: \{ /* ... */ \},\
customers: \{ /* ... */ \},\
inventory: \{ /* ... */ \},\
shipping: \{ /* ... */ \}\
\});\
// Better - focused domains\
const orderNode = createNode("orders");\
orderNode.state.set(\{ orders: \{ /* ... */ \} \});\
const customerNode = createNode("customers");\
customerNode.state.set(\{ customers: \{ /* ... */ \} \});\

\fs32\fsmilli16020 Use Immutable Patterns\

\fs25\fsmilli12816 Always update state immutably to maintain predictability:\

\fs22\fsmilli11214 // AVOID: Direct mutation\
orderNode.state.set(state => \{\
state.orders["order-123"].status = "shipped"; // Mutation!\
return state;\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 116 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // BETTER: Immutable updates\
orderNode.state.set(state => (\{\
...state,\
orders: \{\
...state.orders,\
"order-123": \{\
...state.orders["order-123"],\
status: "shipped"\
\}\
\}\
\}));\

\fs32\fsmilli16020 Prefer Event Communication\

\fs25\fsmilli12816 Use events to communicate state changes between nodes:\

\fs22\fsmilli11214 // When state changes\
orderNode.state.set(/* update state */);\
// Broadcast the change\
orderNode.broadcast(\{\
type: "order-status-changed",\
payload: \{\
orderId: "order-123",\
status: "shipped"\
\}\
\});\

\fs32\fsmilli16020 Let Event Flow Drive State Changes\

\fs25\fsmilli12816 Instead of directly modifying state in response to external conditions, let\
events drive state changes:\

\fs22\fsmilli11214 // Respond to events with state transformations\
orderNode.on("payment-received", event => \{\
orderNode.state.set(state => (\{\
...state,\
orders: \{\
...state.orders,\
[event.payload.orderId]: \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 117 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 [event.payload.orderId]: \{\
...state.orders[event.payload.orderId],\
status: "paid",\
paymentId: event.payload.paymentId,\
paidAt: Date.now()\
\}\
\}\
\}));\
\});\

\fs25\fsmilli12816 By focusing on clear ownership, functional transformations, and event-driven\
communication, you can create systems that are both powerful and\
maintainable. The integration with NATS JetStream's Key-Value store provides\
a robust foundation for distributed state management without adding\
complexity to your application code.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 118 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Data Flow\

\fs25\fsmilli12816 Happen offers a unique approach to system design by providing two\
complementary layers that form a cohesive fabric for the movement,\
management, and manipulation of data: an event system and a state system.\
Rather than forcing you to choose between these approaches, Happen\
enables you to use both simultaneously, allowing you to leverage the\
strengths of each where appropriate.\

\fs38\fsmilli19224 Two Complementary Layers\

\fs25\fsmilli12816 At the heart of Happen are two fundamentally different but complementary\
architectural layers:\

\fs32\fsmilli16020 Event System: The Communication Layer\

\fs25\fsmilli12816 The event system forms the communication layer where nodes interact\
through message passing. Each event represents something that happened,\
and nodes react to these events by processing them and potentially emitting\
new events.\
This layer excels at modeling:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Distributed systems where components operate independently\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Real-time reactions to external stimuli\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Complex communication patterns with rich history tracking\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Systems where the sequence and timing of interactions matter\

\fs32\fsmilli16020 State System: The Data Layer\

\fs25\fsmilli12816 The state system forms the data layer where each node manages its internal\
state. State evolves through well-defined transformations, and nodes can\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 119 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 access and modify their state in a consistent manner.\
This layer excels at modeling:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Entity lifecycles with clear states and transformations\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Consistent, atomic updates across multiple entities\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Business processes with well-defined rules\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Systems where the current state determines what can happen next\

\fs38\fsmilli19224 Distinct APIs for Distinct Concerns\

\fs25\fsmilli12816 Happen provides separate APIs for each layer, making it clear which layer\
you're working with:\

\fs22\fsmilli11214 const orderNode = createNode("order-service");\
// Event System: Process events through handlers\
orderNode.on(type => type === "order-submitted", (event) => \{\
validateOrder(event.payload);\
orderNode.broadcast(\{\
type: "order-validated",\
payload: \{\
orderId: event.payload.orderId,\
items: event.payload.items\
\}\
\});\
\});\
// State System: Transform state through the .state namespace\
orderNode.state.set(state => \{\
return \{\
...state,\
orders: \{\
...state.orders,\
"order-123": \{\
...state.orders["order-123"],\
status: "processing",\
processedAt: Date.now()\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 120 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \}\
\}\
\};\
\});\

\fs25\fsmilli12816 This clear separation of concerns allows you to use the right tool for each task\
without artificial constraints.\

\fs38\fsmilli19224 Layer Interaction\

\fs25\fsmilli12816 While the event and state layers are conceptually distinct, they interact\
seamlessly within nodes:\

\fs22\fsmilli11214 // Event processing triggering state changes\
paymentNode.on(type => type === "payment-received", (event) => \{\
const \{ orderId, amount \} = event.payload;\
// Process the payment\
const result = processPayment(event.payload);\
// Update state in response to the event\
paymentNode.state.set(state => \{\
const orders = state.orders || \{\};\
const order = orders[orderId] || \{\};\
return \{\
...state,\
orders: \{\
...orders,\
[orderId]: \{\
...order,\
paymentStatus: "paid",\
paymentId: result.transactionId,\
paidAt: Date.now()\
\}\
\}\
\};\
\});\
// Emit another event based on the state change\
paymentNode.broadcast(\{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 121 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 type: "payment-confirmed",\
payload: \{\
orderId,\
transactionId: result.transactionId\
\}\
\});\
\});\

\fs25\fsmilli12816 This ability to seamlessly move between layers allows you to create systems\
where communication and state management work together naturally.\

\fs38\fsmilli19224 State Operations\

\fs25\fsmilli12816 The state system provides powerful capabilities for managing state at\
different granularities.\

\fs32\fsmilli16020 Individual Entity Operations\

\fs25\fsmilli12816 For focused state updates on specific entities:\

\fs22\fsmilli11214 // Individual entity transformation\
orderNode.state.set(state => \{\
const orders = state.orders || \{\};\
const order = orders["order-123"] || \{\};\
return \{\
...state,\
orders: \{\
...orders,\
"order-123": \{\
...order,\
status: "processing"\
\}\
\}\
\};\
\});\

\fs32\fsmilli16020 Multi-Entity Operations\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 122 of 234Happen\

\f1\fs32\fsmilli16020 \cf3 Multi-Entity Operations\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 For operations that need to maintain consistency across multiple entities:\

\fs22\fsmilli11214 // Multi-entity transformation\
orderNode.state.set((state, views) => \{\
// Get state from this node\
const orders = state.orders || \{\};\
const order = orders["order-123"];\
if (!order) return state;\
// Get state from inventory node through views\
const inventory = views.inventory.get();\
// Update both order and inventory\
const updatedInventory = updateInventory(inventory, order.items);\
// Return transformed state\
return \{\
...state,\
orders: \{\
...orders,\
"order-123": \{\
...order,\
status: "processing"\
\}\
\}\
\};\
\});\

\fs32\fsmilli16020 Functional Composition\

\fs25\fsmilli12816 The state system embraces functional composition as a core principle,\
allowing you to build complex transformations from simpler ones:\

\fs22\fsmilli11214 // Define transformation functions\
const validateOrder = (state) => (\{\
...state,\
validated: true,\
validatedAt: Date.now()\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 123 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \});\
const processPayment = (state) => (\{\
...state,\
paymentProcessed: true,\
paymentProcessedAt: Date.now()\
\});\
const prepareShipment = (state) => (\{\
...state,\
shipmentPrepared: true,\
shipmentPreparedAt: Date.now()\
\});\
// Apply composed transformation\
orderNode.state.set(state => \{\
// Get the order\
const orders = state.orders || \{\};\
const order = orders["order-123"] || \{\};\
// Base transformation\
const baseState = \{\
...order,\
status: "processing"\
\};\
// Apply composed transformations\
const processedOrder = [validateOrder, processPayment,\
prepareShipment]\
.reduce((currentState, transform) => transform(currentState),\
baseState);\
// Return the updated state\
return \{\
...state,\
orders: \{\
...orders,\
"order-123": processedOrder\
\}\
\};\
\});\

\fs25\fsmilli12816 This functional approach allows for powerful, flexible composition without\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 124 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 requiring special helpers or syntax.\

\fs38\fsmilli19224 When to Use Each Layer\

\fs25\fsmilli12816 While Happen allows you to freely use both layers, here are some guidelines\
for choosing the right approach:\
Use the Event System when:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 You need to communicate between nodes\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Events arrive from external sources\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 The history and sequence of interactions matter\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 You need to broadcast information to multiple recipients\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 You're modeling reactive behavior\
Use the State System when:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 You need atomic updates to a node's state\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 State consistency is critical\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 You're working with well-defined entity lifecycles\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 You need to validate state changes before applying them\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 You're modeling procedural behavior\

\fs38\fsmilli19224 The Best of Both Worlds\

\fs25\fsmilli12816 By providing both event and state layers, Happen allows you to build systems\
that are:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Reactive to external events and stimuli\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Consistent in their state management\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Distributed across multiple components\

\f2\fs38\fsmilli19224 \cf5 \'95\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 125 of 234Happen\
7/7/25, 07:52\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Predictable in their behavior\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Flexible in their evolution\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Comprehensible to developers\
This dual-layer architecture gives Happen a unique power: the ability to create\
complex systems where communication and state management work together\
seamlessly, using the right approach for each concern.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 126 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Temporal State\

\fs25\fsmilli12816 In Happen, the journey is just as important as the destination. Temporal State\
leverages NATS JetStream's powerful capabilities to provide access to your\
state across time, enabling powerful historical analysis and recovery with\
minimal complexity.\
Temporal State gives nodes the ability to access and work with historical state\
\'97allowing you to see not just what your state is now, but what it was at\
important points in your application's history.\

\fs38\fsmilli19224 How Temporal State Works with JetStream\

\fs25\fsmilli12816 At its core, Temporal State in Happen is built on NATS JetStream's key\
features:\
\cf5 1. \cf3 Durable Streams: JetStream stores sequences of messages with\
configurable retention\
\cf5 2. \cf3 Key-Value Store: Built on streams, preserves state changes as versioned\
entries\
\cf5 3. \cf3 Message Headers: Carry metadata about events, including causal\
relationships\
\cf5 4. \cf3 Event Sourcing Pattern: Natural event sourcing capabilities through\
message ordering\
When an event flows through a node and modifies state, both the event and\
the resulting state change are recorded in JetStream:\

\fs22\fsmilli11214 \{\
// Conceptually, a temporal state snapshot includes:\
state: \{ /* state at this point in time */ \},\
context: \{ // Essential event context\
id: 'evt-456', // The event that created this state\
causationId: 'evt-123', // What caused this event\
correlationId: 'order-789', // Transaction this event belongs\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 127 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 correlationId: 'order-789', // Transaction this event belongs\
to\
sender: 'payment-service', // Node that sent the event\
timestamp: 1621452789000, // When it happened\
eventType: 'payment-processed' // Type of event\
\}\
\}\

\fs25\fsmilli12816 This combination of event and state history provides a complete record of\
how your system evolved over time.\

\fs38\fsmilli19224 JetStream Key-Value Store for Historical State\

\fs25\fsmilli12816 Happen uses JetStream's Key-Value store capabilities to implement Temporal\
State:\

\fs22\fsmilli11214 // Initialize with Temporal State configuration\
const happen = initializeHappen(\{\
nats: \{\
capabilities: \{\
persistence: \{\
enabled: true,\
keyValue: \{\
enabled: true,\
buckets: \{\
state: "happen-state",\
temporal: "happen-temporal"\
\}\
\},\
// Temporal state configuration\
temporal: \{\
enabled: true,\
history: 100, // Keep 100 versions per key\
maxAge: "30d" // Keep history for 30 days\
\}\
\}\
\}\
\}\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 128 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 This configuration creates a specialized Key-Value bucket that preserves\
historical versions of state entries.\

\fs38\fsmilli19224 Accessing Temporal State\

\fs25\fsmilli12816 Happen provides a clean and intuitive way to access historical state through\
the 
\fs22\fsmilli11214 .when() 
\fs25\fsmilli12816 function:\

\fs22\fsmilli11214 // Access state after a specific event\
orderNode.state.when('evt-123', (snapshots) => \{\
// Work with the complete historical snapshot\
const \{ state, context \} = snapshots[0];\
console.log(`Order status was: $\{state.orders["order-\
123"].status\}`);\
console.log(`Event type: $\{context.eventType\}`);\
console.log(`Caused by: $\{context.causationId\}`);\
return processHistoricalState(state, context);\
\});\

\fs25\fsmilli12816 The 
\fs22\fsmilli11214 when 
\fs25\fsmilli12816 function follows Happen's pattern-matching approach, accepting\
either:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 A string event ID: 'evt-123'\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 A function matcher: 
\fs22\fsmilli11214 eventId => eventId.startsWith('payment-')\

\fs38\fsmilli19224 Traversing Causal Chains\

\fs25\fsmilli12816 Since each snapshot includes context information, you can easily traverse\
causal chains using pattern matching:\

\fs22\fsmilli11214 // Find all states caused by a specific event\
orderNode.state.when(\
event => event.causationId === 'evt-123',\
(snapshots) => \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 129 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 (snapshots) => \{\
// Process all snapshots directly caused by evt-123\
const eventTypes = snapshots.map(snap =>\
snap.context.eventType);\
console.log(`Event evt-123 caused these events:\
$\{eventTypes.join(', ')\}`);\
return analyzeEffects(snapshots);\
\}\
);\
// Or use correlation IDs to get entire transaction flows\
orderNode.state.when(\
event => event.correlationId === 'order-789',\
(snapshots) => \{\
// Process all snapshots in the transaction\
// Arrange by timestamp to see the sequence\
const eventSequence = [...snapshots]\
.sort((a, b) => a.context.timestamp - b.context.timestamp)\
.map(snap => snap.context.eventType);\
console.log(`Transaction order-789 flow: $\{eventSequence.join('\

\f3 \uc0\u8594 
\f1  ')\}`);\
return createAuditTrail(snapshots);\
\}\
);\

\fs38\fsmilli19224 Efficient Implementation through JetStream\

\fs25\fsmilli12816 Rather than storing complete copies of state for every event, Happen\
leverages JetStream's efficient storage capabilities:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 JetStream automatically compresses and deduplicates data\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Key revisions are tracked with minimal overhead\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 The system intelligently manages resource usage\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Historical data is pruned based on configurable policies\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 130 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 This approach balances efficient storage with powerful historical access\
capabilities.\

\fs38\fsmilli19224 Customizing Retention Policies\

\fs25\fsmilli12816 Happen allows you to customize which historical states are retained through\
JetStream's retention policies:\

\fs22\fsmilli11214 // Node with custom retention policy\
const orderNode = createNode('order-service', \{\
persistence: \{\
temporal: \{\
history: 50, maxAge: "7d", subject: "order.*" // Keep up to 50 versions\
// Keep history for 7 days\
// Only track states for order events\
\}\
\}\
\});\

\fs25\fsmilli12816 This gives you control over:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 How many historical versions to keep\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 How long to keep historical versions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Which events should create temporal snapshots\

\fs38\fsmilli19224 Event Sourcing\

\fs25\fsmilli12816 Temporal State makes implementing the Event Sourcing pattern remarkably\
straightforward:\

\fs22\fsmilli11214 // Rebuild state at a specific point in time\
orderNode.state.when('evt-123', (snapshot) => \{\
// Replace current state with historical state\
orderNode.state.set(() => snapshot.state);\
// Let the system know we rebuilt state\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 131 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Let the system know we rebuilt state\
orderNode.broadcast(\{\
type: 'state-rebuilt',\
payload: \{\
fromEvent: snapshot.context.id,\
timestamp: snapshot.context.timestamp\
\}\
\});\
return \{ rebuilt: true \};\
\});\

\fs38\fsmilli19224 Recovery and Resilience\

\fs25\fsmilli12816 Temporal State provides natural resilience capabilities:\

\fs22\fsmilli11214 // After node restart, recover from latest known state\
function recoverLatestState() \{\
// Find the latest event we processed before crashing\
const latestEventId = loadLatestEventIdFromDisk();\
if (latestEventId) \{\
// Recover state from that point\
orderNode.state.when(latestEventId, (snapshot) => \{\
if (snapshot) \{\
// Restore state\
orderNode.state.set(() => snapshot.state);\
console.log('State recovered successfully');\
\}\
\});\
\}\
\}\

\fs38\fsmilli19224 Benefits of JetStream-Powered Temporal State\

\fs25\fsmilli12816 Happen's JetStream-based approach to Temporal State offers several key\
advantages:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 132 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 1. \cf3 Durable History: State history persists even across system restarts\
\cf5 2. \cf3 Efficient Storage: JetStream optimizes storage with minimal overhead\
\cf5 3. \cf3 Causal Tracking: Event relationships are preserved throughout history\
\cf5 4. \cf3 Tunable Retention: Customize retention based on your specific needs\
\cf5 5. \cf3 Cross-Node Consistency: Historical state is consistent across node\
instances\
\cf5 6. \cf3 Performance: JetStream provides high-performance access to historical\
data\
\cf5 7. \cf3 Scalability: Works from single-process to globally distributed systems\
By leveraging NATS JetStream's capabilities, Happen provides powerful\
temporal state features without the complexity typically associated with time-\
travel debugging and historical analysis.\
Adding the dimension of time to your application's data model, Temporal State\
opens up powerful capabilities with minimal added complexity. Since it builds\
on NATS JetStream's existing features, it provides powerful capabilities that\
feel natural and integrated.\
With Temporal State, your applications gain new powers for auditing,\
debugging, analysis, recovery, and understanding\'97all while maintaining\
Happen's commitment to simplicity and power through minimal primitives.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 133 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 The Unified Event Space\

\fs25\fsmilli12816 In Happen, events flow seamlessly across process, network, and environment\
boundaries through a unified NATS backbone. This approach eliminates the\
artificial boundaries typically found in distributed systems, enabling you to\
build applications that span multiple processes and environments with the\
same simplicity as local ones.\

\fs38\fsmilli19224 Beyond Boundaries\

\fs25\fsmilli12816 Happen's unified event space means you write code the same way regardless\
of where nodes are deployed:\

\fs22\fsmilli11214 // The exact same code works whether nodes are:\
// - In the same process\
// - In different processes on the same machine\
// - Distributed across different machines\
// - In completely different environments (server, browser, edge)\
orderNode.send(inventoryNode, \{\
type: "check-inventory",\
payload: \{ orderId: "123", items: [...] \}\
\});\

\fs25\fsmilli12816 This isn't just an API convenience\'97it's a fundamental design principle that\
creates location transparency throughout your system. Nodes can be\
deployed wherever makes the most sense for your architecture, and your\
code remains unchanged.\

\fs38\fsmilli19224 How the Unified Event Space Works\

\fs25\fsmilli12816 At the heart of Happen's unified event space is the NATS messaging system\
with its JetStream persistence layer. When an event crosses boundaries:\
\cf5 1. \cf3 The event is automatically serialized using MessagePack\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 134 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 2. \cf3 NATS delivers it to the appropriate destination\
\cf5 3. \cf3 The event is deserialized on arrival\
\cf5 4. \cf3 The receiving node processes it using standard event handlers\
All of this happens transparently\'97your code simply uses 
\fs22\fsmilli11214 send() 
\fs25\fsmilli12816 and 
\fs22\fsmilli11214 on()\

\fs25\fsmilli12816 without needing to know whether communication is local or remote.\

\fs38\fsmilli19224 Cross-Boundary Serialization\

\fs25\fsmilli12816 When events cross process or network boundaries in Happen, they are\
efficiently handled through a streamlined serialization strategy:\

\fs32\fsmilli16020 JSON Interface, Binary Transport\

\fs25\fsmilli12816 Happen provides a natural JSON-like interface for developers while using\
efficient binary serialization under the hood:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Developer Experience: Work with standard JavaScript objects in your\
code\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Transport Efficiency: MessagePack binary format used for actual\
transmission\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Transparent Conversion: Serialization/deserialization happens\
automatically\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 No Schema Required: Maintains Happen's schema-free flexibility\
This approach gives you the best of both worlds - the simplicity of working\
with native JavaScript objects and the efficiency of binary transport.\

\fs38\fsmilli19224 Preserving Causality Across Boundaries\

\fs25\fsmilli12816 One of the most powerful aspects of Happen's unified event space is how it\
maintains causality across boundaries. Every event carries its complete\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 135 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 causal context:\

\fs22\fsmilli11214 // When an event crosses a boundary, its context is preserved\
\{\
type: "inventory-reserved",\
payload: \{\
orderId: "order-123",\
items: [/* ... */]\
\},\
context: \{\
causal: \{\
id: "evt-789", // Unique event ID\
sender: "inventory-node", // Originating node\
causationId: "evt-456", // Event that caused this one\
correlationId: "txn-123", // Transaction this belongs to\
path: [ // Complete journey\
["user-node", "order-node"],\
["order-node", "inventory-node"]\
]\
\}\
\}\
\}\

\fs25\fsmilli12816 This causal context creates a complete web of relationships that spans your\
entire distributed system.\

\fs38\fsmilli19224 Unified Configuration\

\fs25\fsmilli12816 Happen provides a clean, explicit approach to configuration that separates\
environment concerns from application logic:\

\fs22\fsmilli11214 // Initialize Happen with NATS as the universal backbone\
const happen = initializeHappen(\{\
// NATS configuration\
nats: \{\
// Connection configuration\
connection: \{\
// Server environment (direct NATS)\
server: \{\
servers: ['nats://server:4222'],\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 136 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 servers: ['nats://server:4222'],\
jetstream: true\
\},\
// Browser environment (WebSocket)\
browser: \{\
servers: ['wss://server:8443'],\
jetstream: true\
\}\
\},\
// Enable key features\
capabilities: \{\
// Persistence through JetStream\
persistence: \{\
enabled: true,\
// Use Key-Value store for state\
keyValue: \{\
enabled: true,\
buckets: \{\
state: "happen-state",\
temporal: "happen-temporal"\
\}\
\}\
\},\
// Delivery guarantees\
delivery: \{\
exactlyOnce: true,\
deduplication: true\
\}\
\}\
\}\
\});\

\fs38\fsmilli19224 Node-Level Configuration\

\fs25\fsmilli12816 Individual nodes can specify their own delivery requirements:\

\fs22\fsmilli11214 // Node with specific reliability requirements\
const paymentNode = createNode("payment-service", \{\
// Delivery guarantees for this specific node\
delivery: \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 137 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 delivery: \{\
exactlyOnce: true,\
acknowledge: true,\
timeout: 5000, // ms\
retries: 3\
\}\
\});\

\fs38\fsmilli19224 Large Payload Management\

\fs25\fsmilli12816 For handling large data across boundaries, Happen leverages NATS Key-Value\
store to provide a global namespace:\

\fs32\fsmilli16020 The Global Namespace\

\fs22\fsmilli11214 // Store large data\
const key = `data:$\{generateId()\}`;\
node.global.set(key, largeData);\
// Reference in events\
node.send(targetNode, \{\
type: "process-data",\
payload: \{ dataKey: key \}\
\});\
// Retrieve on the other side\
const data = await targetNode.global.get(event.payload.dataKey);\

\fs38\fsmilli19224 Handling Network Realities\

\fs25\fsmilli12816 Real-world networks are unreliable. Happen's NATS-based transport layer\
addresses these realities directly:\

\fs32\fsmilli16020 Persistent Delivery\

\fs25\fsmilli12816 Events can be stored in JetStream's durable storage until successfully\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 138 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 processed, ensuring:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Durability: Events survive process restarts\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Guaranteed Delivery: Events reach their destination even after network\
issues\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Natural Backpressure: JetStream provides backpressure for overloaded\
consumers\

\fs32\fsmilli16020 Network Partitions\

\fs25\fsmilli12816 During network partitions:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Nodes continue operating within their connected segments\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Events destined for disconnected nodes are stored in JetStream\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 When connectivity resumes, stored events are delivered\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Causality is preserved throughout this process\
This happens automatically through JetStream's durable storage capabilities.\

\fs38\fsmilli19224 Cross-Environment Communication\

\fs25\fsmilli12816 The unified transport system makes cross-environment communication\
seamless:\

\fs22\fsmilli11214 // Server-side node sending to browser client\
serverNode.on("update-client", (event) => \{\
// Use the standard send method - routing happens automatically\
serverNode.send(browserNode, \{\
type: "data-updated",\
payload: event.payload.data\
\});\
\});\

\fs38\fsmilli19224 Benefits of the Unified Event Space\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 139 of 234Happen\

\f1\fs38\fsmilli19224 \cf3 Benefits of the Unified Event Space\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 This approach to distributed events creates powerful capabilities:\
\cf5 1. \cf3 Location Transparency: Your code doesn't need to know or care where\
nodes are deployed\
\cf5 2. \cf3 Protocol Flexibility: The right protocol is selected automatically for each\
environment\
\cf5 3. \cf3 Environment Adaptability: Seamlessly bridge between server, browser,\
and edge environments\
\cf5 4. \cf3 Deployment Freedom: Components can move between environments by\
simply changing deployment configuration\
\cf5 5. \cf3 Resilient Architecture: Systems naturally handle network fluctuations\
through JetStream\
\cf5 6. \cf3 Future Extensibility: Easily adopt new NATS capabilities as they become\
available\
By providing a truly unified event space powered by NATS, Happen enables\
you to focus on your application's domain rather than the complexities of\
distributed systems.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 140 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Identity & Auth\

\fs25\fsmilli12816 Happen provides the minimal, essential tools that enable developers to build\
their own identity models. Here's what that looks like:\

\fs38\fsmilli19224 1. Node Identity\

\fs25\fsmilli12816 Every node in Happen possesses a unique identity established at creation:\

\fs22\fsmilli11214 const orderNode = createNode('order-service');\

\fs25\fsmilli12816 This creates a node with a cryptographic identity that:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Is established automatically at node creation\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Is used to verify the origin of events\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Remains consistent throughout the node's lifecycle\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Can be referenced by other nodes\
Node identity is foundational to Happen's event flow, enabling verifiable\
communication between components without requiring elaborate identity\
infrastructure.\

\fs38\fsmilli19224 2. Origin Context\

\fs25\fsmilli12816 Events in Happen carry origin information in their context, providing a clear\
record of where events came from:\

\fs22\fsmilli11214 \{\
type: "order-created",\
payload: \{\
// Domain-specific data\
orderId: "order-123",\
items: [/* items data */]\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 141 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 items: [/* items data */]\
\},\
context: \{\
causal: \{\
id: "evt-789",\
sender: "checkout-node",\
causationId: "evt-456",\
correlationId: "txn-123"\
\},\
origin: \{\
nodeId: "checkout-node", (added automatically)\
sourceId: "user-456", application-provided)\
sourceType: "user" \}\
// The immediate sender node\
// Original source (optional,\
// Type of source (optional)\
\}\
\}\

\fs25\fsmilli12816 The origin context provides:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 nodeId: The node that immediately sent the event (added automatically)\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 sourceId: The original source identity (e.g., user ID, service ID)\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 sourceType: The type of source (e.g., "user", "system", "service")\
This minimal but powerful primitive allows events to carry essential identity\
information without prescribing how that information should be structured or\
used.\

\fs38\fsmilli19224 3. Acceptance Controls\

\fs25\fsmilli12816 Nodes can specify which origins they're willing to accept events from:\

\fs22\fsmilli11214 const paymentNode = createNode("payment-service", \{\
acceptFrom: [\
"checkout-node", "user:admin", "order-*" // Accept from specific node\
// Accept from specific user type/role\
// Accept from nodes matching pattern\
]\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 142 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 ]\
\});\

\fs25\fsmilli12816 This declarative approach provides a simple way to control event flow based\
on origin, without requiring complex configuration or policy engines.\

\fs38\fsmilli19224 How Happen Enables Identity Models\

\fs25\fsmilli12816 By providing these blocks rather than a complete identity system, Happen\
enables developers to:\

\fs32\fsmilli16020 Build Custom Identity Models\

\fs22\fsmilli11214 // Example: Multi-tenant identity model\
function createTenantNode(tenantId, nodeId) \{\
return createNode(nodeId, \{\
// Only accept events from the same tenant\
acceptFrom: [`tenant:$\{tenantId\}:*`]\
\});\
\}\
// When sending events, include tenant context\
sourceNode.send(targetNode, \{\
type: "process-data",\
payload: \{/* data */\},\
context: \{\
origin: \{\
sourceId: `tenant:$\{tenantId\}:user-123`,\
sourceType: "user"\
\}\
\}\
\});\

\fs32\fsmilli16020 Create Domain-Specific Authorization\

\fs22\fsmilli11214 // Custom authorization using the Event Continuum\
orderNode.on("update-order", (event, context) => \{\
// Extract origin information\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 143 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Extract origin information\
const \{ sourceId, sourceType \} = event.context.origin;\
// Get the order\
const order = getOrder(event.payload.orderId);\
// Check if the source has permission to update this order\
if (sourceType === "user" && order.customerId !== sourceId) \{\
return \{\
success: false,\
reason: "unauthorized",\
message: "Users can only update their own orders"\
\};\
\}\
// Continue with authorized flow\
return processOrderUpdate;\
\});\

\fs32\fsmilli16020 Implement Delegation Patterns\

\fs22\fsmilli11214 // Forward events while preserving original source\
apiNode.on("create-order", (event, context) => \{\
// Preserve the original source when forwarding\
return apiNode.send(orderNode, \{\
type: "process-order",\
payload: event.payload,\
context: \{\
origin: \{\
// Keep original source information\
sourceId: event.context.origin.sourceId,\
sourceType: event.context.origin.sourceType\
\}\
\}\
\});\
\});\

\fs38\fsmilli19224 Embracing Causality\

\fs25\fsmilli12816 The identity system in Happen is designed to work seamlessly with its causal\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 144 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 model:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Each event naturally references its sender node\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 The causal chain provides a complete history of who did what\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Origin information flows through event chains\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 The combination creates a natural audit trail\
This integration means that identity becomes an inherent property of the\
event flow rather than a separate concern requiring special handling.\

\fs38\fsmilli19224 The Power of Minimalism\

\fs25\fsmilli12816 By providing just the essential identity apparatus, Happen enables:\
\cf5 1. \cf3 Simple Identity Tracking: Basic origin tracking with zero configuration\
\cf5 2. \cf3 Powerful Custom Models: Build sophisticated identity systems when\
needed\
\cf5 3. \cf3 Domain-Specific Authorization: Implement authorization that matches\
your domain\
\cf5 4. \cf3 Clean Mental Model: Identity as a natural property of events\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 145 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Security\

\fs25\fsmilli12816 Happen provides the minimal, essential tools that enable developers to build\
their own security models.\

\fs38\fsmilli19224 1. Event Identity and Integrity Tooling\

\fs25\fsmilli12816 Event ID Generation: Every event in Happen automatically receives a unique,\
cryptographically secure identifier generated by the framework.\
Automatic Event Hash: The framework automatically calculates and includes\
a cryptographic hash of each event's contents in its causal context:\

\fs22\fsmilli11214 // Example of what an event looks like internally\
\{\
type: "payment-processed",\
payload: \{ amount: 100 \},\
context: \{\
causal: \{\
id: "evt-789", // Unique ID\
hash: "a1b2c3...", // Cryptographic hash\
sender: "payment-node",\
causationId: "evt-456",\
correlationId: "order-123"\
\}\
\}\
\}\

\fs25\fsmilli12816 This hash is calculated from the canonicalized event (without the hash itself)\
using a hashing algorithm provided by the runtime environment.\

\fs38\fsmilli19224 2. Node Identity\

\fs25\fsmilli12816 Identity Container: Every node in Happen has an inherent identity established\
at creation:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 146 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Node identity is established automatically\
const paymentNode = createNode('payment-service');\

\fs25\fsmilli12816 This identity is used to track the origin of events and forms the foundation of\
security verification.\
Identity Propagation: Node identity is automatically included in the causal\
context of emitted events:\

\fs22\fsmilli11214 // The framework automatically includes the sender information\
// in the causal context of every event\
orderNode.send(paymentNode, \{\
type: "process-payment",\
payload: \{ amount: 100 \}\
\});\
// Resulting event includes sender identity\
// \{\
// type: "process-payment",\
// payload: \{ amount: 100 \},\
// context: \{\
// causal: \{\
// sender: "order-service", // Added automatically\
// ...\
// \}\
// \}\
// \}\

\fs25\fsmilli12816 Origin Context: For tracking the original source of events (not just the\
immediate sender):\

\fs22\fsmilli11214 // Adding origin information to events\
orderNode.send(paymentNode, \{\
type: "process-payment",\
payload: \{ amount: 100 \},\
context: \{\
origin: \{\
sourceId: "user-123", sourceType: "user" // Original source (e.g., user ID)\
// Type of source\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 147 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \}\
\}\
\});\

\fs25\fsmilli12816 This allows developers to build their own identity models on top of Happen.\

\fs38\fsmilli19224 3. Causal Chain\

\fs25\fsmilli12816 The causal relationships between events provide a natural foundation for\
security verification:\

\fs22\fsmilli11214 // Events naturally form a causal chain\
event.context.causal = \{\
id: "evt-789",\
sender: "user-service",\
causationId: "evt-456", // Links to the event that caused this\
one\
correlationId: "session-123" // Groups related events\
\};\

\fs25\fsmilli12816 This causality enables:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Tracking the complete flow of events\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Verifying that events occurred in the expected sequence\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Building audit trails based on causal relationships\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Detecting replay or injection attacks\

\fs38\fsmilli19224 4. The Event Continuum for Verification\

\fs25\fsmilli12816 The Event Continuum provides a natural place to implement security\
verification:\

\fs22\fsmilli11214 // Security verification using the Event Continuum\
paymentNode.on("process-payment", function verifyAndProcess(event,\
context) \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 148 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 context) \{\
// Extract security information\
const \{ signature \} = event.context.integrity || \{\};\
const \{ hash \} = event.context.causal;\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Verify using runtime crypto\
if (signature) \{\
const senderPublicKey =\
getPublicKey(event.context.causal.sender);\
if (!verifySignature(hash, signature, senderPublicKey)) \{\
return \{\
success: false,\
reason: "invalid-signature"\
\};\
\}\
\}\
// Continue to payment processing\
return processPayment;\
\});\

\fs25\fsmilli12816 This allows security verification to integrate seamlessly with the normal event\
flow.\

\fs38\fsmilli19224 How These Enable Security\

\fs25\fsmilli12816 By providing building blocks rather than implementations, Happen enables\
developers to build their own security models:\

\fs32\fsmilli16020 Integrity Verification\

\fs22\fsmilli11214 // Using the automatic hash for integrity verification\
paymentNode.on("process-payment", (event, context) => \{\
// Hash verification happens automatically by the framework\
// Can perform additional custom verification if needed\
if (!customVerification(event)) \{\
return \{ success: false, reason: "verification-failed" \};\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 149 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Continue processing\
return processPayment;\
\});\

\fs32\fsmilli16020 Digital Signatures and Tamper Evidence\

\fs22\fsmilli11214 // Signing events using runtime crypto\
orderNode.on("create-order", (event, context) => \{\
// Generate order and prepare payment event\
const paymentEvent = \{\
type: "process-payment",\
payload: \{\
orderId: generateOrderId(),\
amount: calculateTotal(event.payload.items)\
\},\
context: \{\
// Add signature using runtime crypto\
integrity: \{\
signature: signWithRuntimeCrypto(\
event.context.causal.hash,\
getPrivateKey()\
)\
\}\
\}\
\};\
// Send signed event\
return orderNode.send(paymentNode, paymentEvent);\
\});\

\fs32\fsmilli16020 Authorization Patterns\

\fs22\fsmilli11214 // Authorization using the Event Continuum\
resourceNode.on("access-resource", (event, context) => \{\
// Extract source information\
const \{ sourceId, sourceType \} = context.origin || \{\};\
// Check permissions\
if (!hasPermission(sourceId, event.payload.resourceId, "read")) \{\
return \{\
success: false,\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 150 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 success: false,\
reason: "unauthorized",\
message: "User does not have permission to access this\
resource"\
\};\
\}\
// Continue to resource access\
return provideResource;\
\});\

\fs32\fsmilli16020 Multi-tenant Isolation\

\fs22\fsmilli11214 // Tenant isolation using origin information\
dataNode.on("query-data", (event, context) => \{\
// Extract tenant from origin\
const tenantId =\
extractTenantFromSource(context.origin?.sourceId);\
// Enforce tenant isolation\
const tenantScopedQuery = \{\
...event.payload.query,\
tenantId // Add tenant filter to query\
\};\
// Execute scoped query\
const results = executeQuery(tenantScopedQuery);\
return \{ results \};\
\});\

\fs32\fsmilli16020 End-to-End Encryption\

\fs22\fsmilli11214 // Encrypting sensitive payload data\
userNode.on("send-sensitive-message", (event, context) => \{\
// Get recipient's public key\
const recipientPublicKey =\
getPublicKey(event.payload.recipientId);\
// Create encrypted message\
const encryptedMessage = encryptWithRuntimeCrypto(\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 151 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 const encryptedMessage = encryptWithRuntimeCrypto(\
event.payload.sensitiveContent,\
recipientPublicKey\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 );\
// Send message with encrypted content\
return userNode.send(messagingNode, \{\
type: "deliver-message",\
payload: \{\
recipientId: event.payload.recipientId,\
encryptedContent: encryptedMessage\
\}\
\});\
\});\

\fs38\fsmilli19224 Minimal but Powerful\

\fs25\fsmilli12816 The key is to expose the right features in the core event system, without\
baking in specific security implementations by giving developers all the\
building blocks they need without restricting their options.\
These features enable developers to implement:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Digital signatures for event verification\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Role-based access control for node interactions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Attribute-based access policies\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Multi-layer security models\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Custom authentication mechanisms\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Auditing and compliance systems\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 End-to-end encryption for sensitive data\
While keeping the core framework minimal and focused on its primary\
responsibility: the flow of events between nodes.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 152 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Error Handling\

\fs25\fsmilli12816 Error handling implements robust recovery patterns without introducing new\
primitives beyond Nodes and Events.\

\fs38\fsmilli19224 Core Principles\

\fs25\fsmilli12816 Happen's approach to error handling is built on these fundamental principles:\
\cf5 1. \cf3 Errors as Flow Branches: Errors are treated as natural branches in the\
event flow\
\cf5 2. \cf3 Functional Error Handling: Error handlers are just functions that can be\
returned\
\cf5 3. \cf3 Context for Error Information: Error details flow through context between\
functions\
\cf5 4. \cf3 Causal Error Tracking: Errors maintain causal relationships like normal\
events\
\cf5 5. \cf3 Decentralized Recovery: Nodes make local recovery decisions when\
possible\
This approach achieves remarkable power with minimal complexity by\
leveraging existing primitives rather than introducing special error-handling\
constructs.\

\fs38\fsmilli19224 The Functional Error Model\

\fs25\fsmilli12816 In Happen, error handling is fully integrated into the Event Continuum through\
function returns:\

\fs22\fsmilli11214 // Register an event handler\
orderNode.on("process-order", function validateOrder(event,\
context) \{\
// Validate the order\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 153 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Validate the order\
const validation = validateOrderData(event.payload);\
if (!validation.valid) \{\
// Return error handler function on validation failure\
return handleInvalidOrder;\
\}\
// Proceed with valid order\
context.validated = true;\
return processOrder;\
\});\
// Error handler function\
function handleInvalidOrder(event, context) \{\
// Log the validation failure\
logValidationFailure(event.payload);\
// Return error result\
return \{\
success: false,\
reason: "validation-failed",\
details: "Invalid order data"\
\};\
\}\

\fs25\fsmilli12816 This functional approach means:\
\cf5 1. \cf3 Errors are just another branch in the flow\
\cf5 2. \cf3 Error handlers are regular functions\
\cf5 3. \cf3 Error information flows through context\
\cf5 4. \cf3 No special syntax or constructs are needed\

\fs38\fsmilli19224 Error Propagation and Context\

\fs25\fsmilli12816 Error information naturally flows through context:\

\fs22\fsmilli11214 function processPayment(event, context) \{\
try \{\
// Process the payment\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 154 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Process the payment\
const paymentResult = chargeCustomer(event.payload.payment);\
if (!paymentResult.success) \{\
// Store error details in context\
context.error = \{\
code: paymentResult.code,\
message: paymentResult.message,\
timestamp: Date.now(),\
correlationId: event.context.causal.correlationId\
\};\
return handlePaymentFailure;\
\}\
// Success path\
return createShipment;\
\} catch (error) \{\
// Unexpected error - store and return handler\
context.error = \{\
unexpected: true,\
message: error.message,\
stack: error.stack,\
timestamp: Date.now()\
\};\
return handleUnexpectedError;\
\}\
\}\
function handlePaymentFailure(event, context) \{\
// Access error from context\
const \{ error \} = context;\
// Log structured error\
logError("Payment failed", error);\
// Return result with error details\
return \{\
success: false,\
reason: "payment-failed",\
details: error.message,\
code: error.code\
\};\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 155 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 This approach allows error information to flow naturally through the event\
chain, maintaining complete context for diagnostics and recovery.\

\fs38\fsmilli19224 Recovery Patterns\

\fs25\fsmilli12816 Happen's functional approach enables powerful recovery patterns through\
composition.\

\fs32\fsmilli16020 Retry Pattern\

\fs22\fsmilli11214 function processPayment(event, context) \{\
// Initialize retry count\
context.retryCount = context.retryCount || 0;\
try \{\
// Attempt payment processing\
const result = chargeCustomer(event.payload.payment);\
// Success - continue to shipping\
context.payment = result;\
return createShipment;\
\} catch (error) \{\
// Store error\
context.lastError = error;\
// Increment retry count\
context.retryCount++;\
// Determine if we should retry\
if (context.retryCount < 3) \{\
console.log(`Retrying payment ($\{context.retryCount\}/3)...`);\
// Return self to retry\
return processPayment;\
\}\
// Too many retries\
return handlePaymentFailure;\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 156 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \}\
\}\

\fs32\fsmilli16020 Circuit Breaker Pattern\

\fs22\fsmilli11214 // Shared circuit state (could be in external store)\
const circuits = \{\
payment: \{\
failures: 0,\
status: "closed", // closed, open, half-open\
lastFailure: null\
\}\
\};\
function processPayment(event, context) \{\
const circuit = circuits.payment;\
// Check if circuit is open\
if (circuit.status === "open") \{\
return \{\
success: false,\
reason: "service-unavailable",\
message: "Payment service is temporarily unavailable"\
\};\
\}\
try \{\
// Process payment\
const result = chargeCustomer(event.payload.payment);\
// Success - reset circuit if in half-open state\
if (circuit.status === "half-open") \{\
circuit.status = "closed";\
circuit.failures = 0;\
\}\
// Continue with success\
context.payment = result;\
return createShipment;\
\} catch (error) \{\
// Update circuit state\
circuit.failures++;\
circuit.lastFailure = Date.now();\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 157 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Check threshold for opening circuit\
if (circuit.status === "closed" && circuit.failures >= 5) \{\
// Open the circuit\
circuit.status = "open";\
// Schedule reset to half-open\
setTimeout(() => \{\
circuit.status = "half-open";\
\}, 30000); // 30 second timeout\
\}\
// Return error result\
return \{\
success: false,\
reason: "payment-failed",\
message: error.message,\
circuitStatus: circuit.status\
\};\
\}\
\}\

\fs32\fsmilli16020 Fallback Pattern\

\fs22\fsmilli11214 function processPayment(event, context) \{\
try \{\
// Try primary payment processor\
const result =\
primaryPaymentProcessor.charge(event.payload.payment);\
context.payment = result;\
return createShipment;\
\} catch (error) \{\
// Store error for context\
context.primaryError = error;\
// Return fallback function\
return useBackupPaymentProcessor;\
\}\
\}\
function useBackupPaymentProcessor(event, context) \{\
console.log("Primary payment processor failed. Using backup.");\
try \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 158 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 try \{\
// Try fallback processor\
const result =\
backupPaymentProcessor.charge(event.payload.payment);\
// Success - continue normal flow\
context.payment = result;\
context.usedFallback = true;\
return createShipment;\
\} catch (error) \{\
// Both processors failed\
return \{\
success: false,\
reason: "payment-failed",\
message: "Both primary and backup payment processors failed",\
primaryError: context.primaryError.message,\
backupError: error.message\
\};\
\}\
\}\

\fs38\fsmilli19224 Error Events as First-Class Citizens\

\fs25\fsmilli12816 In Happen, errors can also be treated as normal events, enabling system-wide\
error handling:\

\fs22\fsmilli11214 // When detecting an error, broadcast an error event\
paymentNode.on("process-payment", (event, context) => \{\
try \{\
// Process payment\
const result = processPayment(event.payload);\
return \{ success: true, transactionId: result.id \};\
\} catch (error) \{\
// Broadcast error event\
paymentNode.broadcast(\{\
type: "payment.error",\
payload: \{\
orderId: event.payload.orderId,\
error: \{\
message: error.message,\
code: error.code || "UNKNOWN"\
\},\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 159 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \},\
timestamp: Date.now()\
\}\
\});\
// Return failure to the original sender\
return \{\
success: false,\
reason: "payment-error",\
message: error.message\
\};\
\}\
\});\
// Error monitoring node can observe all error events\
monitoringNode.on(type => type.endsWith(".error"), (event) => \{\
// Extract service name from event type\
const service = event.type.split('.')[0];\
// Record error\
recordServiceError(service, event.payload);\
// Check thresholds for alerts\
checkErrorThresholds(service);\
return \{ monitored: true \};\
\});\

\fs38\fsmilli19224 Distributed Error Handling\

\fs25\fsmilli12816 When errors cross node boundaries, they naturally maintain their causal\
context:\

\fs22\fsmilli11214 // Node A: Original error occurs\
nodeA.on("process-task", async (event) => \{\
try \{\
// Process task\
const result = await processTask(event.payload);\
return \{ success: true, result \};\
\} catch (error) \{\
// Return error result\
return \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 160 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 return \{\
success: false,\
reason: "task-failed",\
error: error.message,\
timestamp: Date.now()\
\};\
\}\
\});\
// Node B: Handles failure from Node A\
nodeB.on("orchestrate-workflow", async (event) => \{\
// Call Node A\
const result = await nodeB.send(nodeA, \{\
type: "process-task",\
payload: event.payload.taskData\
\}).return();\
// Check for error\
if (!result.success) \{\
// The error from Node A is now available in Node B\
// with the causal chain intact\
// Handle error based on reason\
if (result.reason === "task-failed") \{\
return handleTaskFailure;\
\}\
return \{\
success: false,\
reason: "workflow-failed",\
cause: result.reason,\
error: result.error\
\};\
\}\
// Continue with success path\
return continueWorkflow;\
\});\

\fs38\fsmilli19224 Supervisor Pattern\

\fs25\fsmilli12816 For system-wide resilience, you can create supervisor nodes that monitor and\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 161 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 manage error recovery:\

\fs22\fsmilli11214 // Create a supervisor node\
const supervisorNode = createNode("system-supervisor");\
// Monitor error events across the system\
supervisorNode.on(type => type.endsWith(".error"), (event) => \{\
// Extract service from event type\
const service = event.type.split('.')[0];\
// Track error frequency\
supervisorNode.state.set(state => \{\
const services = state.services || \{\};\
const serviceState = services[service] || \{ errors: 0,\
lastError: 0 \};\
return \{\
...state,\
services: \{\
...services,\
[service]: \{\
...serviceState,\
errors: serviceState.errors + 1,\
lastError: Date.now()\
\}\
\}\
\};\
\});\
// Check for restart threshold\
const serviceState = supervisorNode.state.get(state =>\
(state.services && state.services[service]) || \{ errors: 0 \}\
);\
if (serviceState.errors >= 5) \{\
// Too many errors - trigger restart\
supervisorNode.broadcast(\{\
type: "service.restart",\
payload: \{\
service,\
reason: "excessive-errors",\
count: serviceState.errors\
\}\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 162 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \});\
// Reset error count\
supervisorNode.state.set(state => (\{\
...state,\
services: \{\
...state.services,\
[service]: \{\
...state.services[service],\
errors: 0,\
lastRestart: Date.now()\
\}\
\}\
\}));\
\}\
return \{ monitored: true \};\
\});\

\fs38\fsmilli19224 Composing Error Handling with Normal Flow\

\fs25\fsmilli12816 Error handling in Happen integrates seamlessly with normal event processing:\

\fs22\fsmilli11214 // Complete order processing flow with error handling\
orderNode.on("process-order", validateOrder);\
function validateOrder(event, context) \{\
// Validate order\
const validation = validateOrderData(event.payload);\
if (!validation.valid) \{\
return handleInvalidOrder;\
\}\
// Store validation result\
context.validatedOrder = \{\
...event.payload,\
validated: true,\
validatedAt: Date.now()\
\};\
// Continue to inventory check\
return checkInventory;\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 163 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 return checkInventory;\
\}\
function checkInventory(event, context) \{\
// Check inventory\
const inventoryResult =\
checkInventoryLevels(context.validatedOrder.items);\
if (!inventoryResult.available) \{\
// Store inventory problem\
context.inventoryIssue = inventoryResult;\
return handleInventoryShortage;\
\}\
// Continue to payment\
return processPayment;\
\}\
function processPayment(event, context) \{\
try \{\
// Process payment\
const paymentResult = chargeCustomer(\
context.validatedOrder.payment,\
calculateTotal(context.validatedOrder.items)\
);\
if (!paymentResult.success) \{\
context.paymentIssue = paymentResult;\
return handlePaymentFailure;\
\}\
// Store payment result\
context.payment = paymentResult;\
// Continue to shipment creation\
return createShipment;\
\} catch (error) \{\
context.error = error;\
return handleUnexpectedError;\
\}\
\}\
function createShipment(event, context) \{\
// Create shipment\
const shipment = createShipmentRecord(\{\
order: context.validatedOrder,\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 164 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 order: context.validatedOrder,\
payment: context.payment\
\});\
// Return success result\
return \{\
success: true,\
orderId: context.validatedOrder.id,\
shipmentId: shipment.id,\
trackingNumber: shipment.trackingNumber\
\};\
\}\
// Error handlers\
function handleInvalidOrder(event, context) \{\
return \{\
success: false,\
reason: "validation-failed",\
details: "Invalid order data"\
\};\
\}\
function handleInventoryShortage(event, context) \{\
const \{ inventoryIssue \} = context;\
// Try to get availability estimate\
const availability =\
estimateAvailability(inventoryIssue.missingItems);\
return \{\
success: false,\
reason: "inventory-shortage",\
unavailableItems: inventoryIssue.missingItems,\
estimatedAvailability: availability\
\};\
\}\
function handlePaymentFailure(event, context) \{\
return \{\
success: false,\
reason: "payment-failed",\
details: context.paymentIssue.message,\
code: context.paymentIssue.code\
\};\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 165 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 function handleUnexpectedError(event, context) \{\
// Log unexpected error\
logError("Unexpected error processing order", context.error);\
return \{\
success: false,\
reason: "system-error",\
message: "An unexpected error occurred"\
\};\
\}\

\fs25\fsmilli12816 Treating errors as branches in the functional flow provides sophisticated error\
handling capabilities without introducing special constructs.\
Key takeaways:\
\cf5 1. \cf3 Use Function Returns for Error Flow: Return error handler functions to\
handle errors\
\cf5 2. \cf3 Leverage Context: Store error information in the context object for\
diagnostics\
\cf5 3. \cf3 Implement Recovery Patterns: Build error recovery using function\
composition\
\cf5 4. \cf3 Apply Resilience Patterns: Implement retry, circuit breakers, and fallbacks\
as needed\
\cf5 5. \cf3 Decentralized Recovery: Let nodes make local decisions about error\
handling\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 166 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Network Resilience\

\fs25\fsmilli12816 In distributed systems, network failures are inevitable. Nodes become\
unreachable, connections fail, and partitions occur. Happen provides\
comprehensive resilience capabilities through NATS and JetStream, creating a\
system that maintains causal integrity even during the most challenging\
network disruptions.\
Happen's approach to network resilience stays true to its philosophy of\
radical simplicity by leveraging NATS' battle-tested features:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Durable Storage: Events are preserved in JetStream before delivery\
attempts\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Guaranteed Delivery: At-least-once and exactly-once delivery semantics\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Automatic Reconnection: NATS clients intelligently reconnect after\
network failures\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Message Replay: Unacknowledged messages are automatically replayed\
when connections recover\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Cross-Region Replication: Messages remain available across geographic\
regions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Causal Ordering: Events maintain their causal relationships throughout\
disruptions\
This creates a self-healing system that requires minimal configuration while\
providing enterprise-grade resilience.\

\fs38\fsmilli19224 Comprehensive Resilience Features\

\fs25\fsmilli12816 Happen combines multiple NATS capabilities to solve the full spectrum of\
network resilience challenges:\

\fs32\fsmilli16020 1. Persistent Message Storage\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 167 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Events are automatically stored in NATS JetStream streams before delivery is\
attempted:\

\fs22\fsmilli11214 // When a node sends an event (internal implementation using NATS)\
function sendEvent(targetNode, event) \{\
// FIRST: Publish to JetStream stream with the event's ID as\
message ID\
// This happens automatically\
// THEN: Deliver to recipient\
// If successful, the recipient acknowledges\
// If unsuccessful, the event remains in JetStream for later\
delivery\
\}\

\fs25\fsmilli12816 This ensures events survive process crashes, network failures, and other\
disruptions.\

\fs32\fsmilli16020 2. Delivery Guarantees\

\fs25\fsmilli12816 Happen supports both at-least-once and exactly-once delivery semantics:\

\fs22\fsmilli11214 // Configure delivery guarantees at system level\
const happen = initializeHappen(\{\
nats: \{\
capabilities: \{\
delivery: \{\
// Choose your delivery semantics\
mode: "exactly-once", // or "at-least-once"\
deduplication: true,\
deduplicationWindow: "5m" // 5 minute window\
\}\
\}\
\}\
\});\
// Or configure per node\
const paymentNode = createNode("payment-service", \{\
delivery: \{\
mode: "exactly-once",\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 168 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 acknowledge: true\
\}\
\});\

\fs25\fsmilli12816 With exactly-once delivery, even if messages are redelivered due to network\
issues, they'll only be processed once.\

\fs32\fsmilli16020 3. Automatic Reconnection\

\fs25\fsmilli12816 NATS clients automatically attempt to reconnect when network connections\
fail:\

\fs22\fsmilli11214 // Configure reconnection behavior\
const happen = initializeHappen(\{\
nats: \{\
connection: \{\
// Reconnection settings\
reconnect: true,\
reconnectTimeWait: 2000, // 2 seconds between attempts\
maxReconnectAttempts: -1 // Unlimited reconnect attempts\
\}\
\}\
\});\

\fs25\fsmilli12816 During reconnection attempts, outbound messages are queued locally until\
the connection is restored.\

\fs32\fsmilli16020 4. Flow Control and Backpressure\

\fs25\fsmilli12816 NATS provides natural backpressure mechanisms that prevent overwhelming\
recipients during recovery:\

\fs22\fsmilli11214 // Configure flow control\
const happen = initializeHappen(\{\
nats: \{\
capabilities: \{\
flowControl: \{\
enabled: true,\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 169 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 enabled: true,\
maxPending: 256 * 1024 // 256KB of pending messages\
\}\
\}\
\}\
\});\

\fs25\fsmilli12816 This ensures that when a node recovers after network issues, it won't be\
flooded with a sudden burst of messages.\

\fs32\fsmilli16020 5. Multi-Region Resilience\

\fs25\fsmilli12816 Happen leverages NATS SuperClusters to provide cross-region resilience:\

\fs22\fsmilli11214 // Configure multi-region operation\
const happen = initializeHappen(\{\
nats: \{\
// SuperCluster configuration\
connection: \{\
servers: ['nats://local-region:4222'],\
jetstream: true\
\},\
// Region configuration\
regions: \{\
primary: "us-west",\
replicas: ["us-east", "eu-central"],\
// Configuration for handling cross-region communication\
coordination: \{\
strategy: "primary-replica",\
conflictResolution: "last-writer-wins"\
\}\
\}\
\}\
\});\

\fs25\fsmilli12816 This enables:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Geographic Redundancy: System continues operating even if an entire\
region fails\

\f2\fs38\fsmilli19224 \cf5 \'95\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 170 of 234Happen\
7/7/25, 07:52\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Data Locality: Process data in the optimal region for performance and\
compliance\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Disaster Recovery: Automatic failover and recovery between regions\

\fs32\fsmilli16020 6. Causal Event Recovery\

\fs25\fsmilli12816 When network connections recover, events are replayed while preserving\
causal relationships:\

\fs22\fsmilli11214 // Receive events in proper causal order after reconnection\
orderNode.on("process-order", (event) => \{\
// After reconnection, events will arrive in causal order\
// with exactly-once processing guarantees\
const \{ orderId \} = event.payload;\
// Process normally - framework handles recovery\
\});\

\fs25\fsmilli12816 This ensures that even after severe network disruptions, your application's\
causal integrity is maintained.\

\fs38\fsmilli19224 Resilience Across Environment Boundaries\

\fs25\fsmilli12816 Happen's resilience capabilities work seamlessly across different runtime\
environments:\

\fs32\fsmilli16020 Server Environments\

\fs25\fsmilli12816 In server environments, NATS clients connect directly to the NATS server:\

\fs22\fsmilli11214 // Server node connecting directly to NATS\
const serverNode = createNode("backend-service");\

\fs32\fsmilli16020 Browser Environments\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 171 of 234Happen\

\f1\fs32\fsmilli16020 \cf3 Browser Environments\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 In browser environments, clients connect through WebSockets:\

\fs22\fsmilli11214 // Browser node connecting via WebSockets\
const browserNode = createNode("frontend-client");\

\fs32\fsmilli16020 Edge/IoT Environments\

\fs25\fsmilli12816 For edge or IoT devices with intermittent connectivity:\

\fs22\fsmilli11214 // Edge node with specialized configuration\
const edgeNode = createNode("sensor-device", \{\
// Configuration for intermittent connectivity\
connectivity: \{\
mode: "intermittent",\
localBuffering: true,\
syncOnConnect: true\
\}\
\});\

\fs25\fsmilli12816 In all these environments, the same resilience guarantees apply, providing\
consistent behavior regardless of where nodes are running.\

\fs38\fsmilli19224 Application Integration\

\fs25\fsmilli12816 While network resilience operates automatically, applications can optionally\
integrate with the system for enhanced awareness:\

\fs22\fsmilli11214 // Listen for connection status events\
orderNode.on('system.connection-status', (event) => \{\
const \{ status, reason \} = event.payload;\
if (status === 'disconnected') \{\
// Update UI to show connectivity issue\
updateConnectionStatus('degraded', reason);\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 172 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Enable offline mode\
enableOfflineMode();\
\} else if (status === 'reconnected') \{\
// Update UI to show restored connectivity\
updateConnectionStatus('connected');\
// Return to normal operation\
disableOfflineMode();\
\}\
\});\

\fs25\fsmilli12816 This allows applications to:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Notify users about connectivity issues\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Adapt UI behavior during disruptions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Log network problems for diagnostics\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Enable offline capabilities when appropriate\

\fs38\fsmilli19224 Key-Value Store for Persistent State\

\fs25\fsmilli12816 In addition to message persistence, Happen leverages NATS JetStream's Key-\
Value store for durable state:\

\fs22\fsmilli11214 // State is automatically persisted in JetStream KV store\
orderNode.state.set(state => (\{\
...state,\
orders: \{\
...state.orders,\
"order-123": \{\
status: "processing",\
updatedAt: Date.now()\
\}\
\}\
\}));\

\fs25\fsmilli12816 This ensures that node state persists across restarts and can be shared\
across instances, providing:\

\f2\fs38\fsmilli19224 \cf5 \'95\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 173 of 234Happen\
7/7/25, 07:52\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Durable State: State persists even if nodes restart\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Consistent State: Updates maintain causal ordering\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Shared State: State can be accessed from multiple instances\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Versioned State: Each update creates a new version that can be tracked\

\fs38\fsmilli19224 Comprehensive Network Failure Handling\

\fs25\fsmilli12816 Happen's NATS-based architecture handles the full spectrum of network\
failures:\

\fs32\fsmilli16020 Process Crashes\

\fs25\fsmilli12816 If a process crashes:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Events are preserved in JetStream\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 State is preserved in the Key-Value store\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Upon restart, the node resumes processing where it left off\

\fs32\fsmilli16020 Network Partitions\

\fs25\fsmilli12816 During network partitions:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Nodes continue functioning in their connected segments\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Events for unreachable nodes are stored in JetStream\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 When the partition heals, normal operation resumes automatically\

\fs32\fsmilli16020 Regional Outages\

\fs25\fsmilli12816 During regional outages:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Traffic automatically routes to available regions\

\f2\fs38\fsmilli19224 \cf5 \'95\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 174 of 234Happen\
7/7/25, 07:52\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 When the region recovers, it synchronizes with the rest of the system\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Causal relationships are preserved across regions\

\fs32\fsmilli16020 Temporary Disconnections\

\fs25\fsmilli12816 During temporary disconnections:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 NATS clients automatically attempt to reconnect\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Outbound messages queue locally\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Upon reconnection, normal event flow resumes\

\fs32\fsmilli16020 Long-Term Outages\

\fs25\fsmilli12816 For long-term outages:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Events are preserved in JetStream for the configured retention period\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 State remains in the Key-Value store\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 When connectivity is restored, normal operation resumes\

\fs38\fsmilli19224 Benefits of NATS-Powered Resilience\

\fs25\fsmilli12816 Happen's NATS-based approach to network resilience offers several key\
advantages:\
\cf5 1. \cf3 Battle-Tested Foundation: Built on NATS' proven resilience capabilities\
\cf5 2. \cf3 Zero Data Loss: Events are preserved even during severe disruptions\
\cf5 3. \cf3 Exactly-Once Processing: No duplicate processing, even during recovery\
\cf5 4. \cf3 Self-Healing: System automatically recovers when issues resolve\
\cf5 5. \cf3 Cross-Environment Consistency: Same resilience guarantees across all\
environments\
\cf5 6. \cf3 Minimal Configuration: Works out of the box with sensible defaults\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 175 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 7. \cf3 Global Scale: Extends from single-process to worldwide deployments\
By leveraging NATS and JetStream, Happen provides enterprise-grade\
resilience capabilities without the complexity typically associated with\
distributed systems. Your application can focus on business logic while the\
framework handles the challenging aspects of network resilience.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 176 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 A Few Design Patterns\

\fs32\fsmilli16020 Event Sourcing Pattern\

\fs25\fsmilli12816 The Event Sourcing pattern stores all changes to an application state as a\
sequence of events, making it possible to reconstruct past states and provide\
a complete audit trail. Happen's causality-focused approach makes this\
pattern particularly elegant.\

\fs22\fsmilli11214 // Create an event store node\
const eventStore = createNode("event-store");\
// Store domain events\
eventStore.on(type => type.startsWith("domain-"), (event) => \{\
// Store event in append-only log\
storeEvent(event);\
return \{ stored: true \};\
\});\
// Function to reconstruct state from events\
function rebuildState() \{\
let state = initialState();\
for (const event of retrieveEvents()) \{\
// Apply each event to evolve the state\
state = applyEvent(state, event);\
\}\
return state;\
\}\
// Function to get state at a specific point in time\
function getStateAt(timestamp) \{\
let state = initialState();\
for (const event of retrieveEvents()) \{\
if (event.metadata.timestamp <= timestamp) \{\
state = applyEvent(state, event);\
\}\
\}\
return state;\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 177 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 This pattern leverages Happen's natural event flow to create an immutable\
record of all domain changes, enabling powerful historical analysis and\
debugging.\

\fs32\fsmilli16020 Command Query Responsibility Segregation (CQRS)\

\fs25\fsmilli12816 CQRS separates operations that modify state (commands) from operations\
that read state (queries), allowing each to be optimized independently.\

\fs22\fsmilli11214 // Command handling node\
const orderCommandNode = createNode("order-commands");\
// Process commands that modify state\
orderCommandNode.on("create-order", (event) => \{\
// Validate command\
validateOrderData(event.payload);\
// Execute command logic\
const orderId = generateOrderId();\
// Emit domain event representing the result\
orderCommandNode.broadcast(\{\
type: "domain-order-created",\
payload: \{ orderId, ...event.payload, createdAt: Date.now() \}\
\});\
\});\
// Query handling node\
const orderQueryNode = createNode("order-queries");\
// Update query model when domain events occur\
orderQueryNode.on("domain-order-created", (event) => \{\
// Update query-optimized state\
orderQueryNode.state.set(state => \{\
const orders = state.orders || \{\};\
return \{\
...state,\
orders: \{\
...orders,\
[event.payload.orderId]: \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 178 of 234\

\f1\fs22\fsmilli11214 \cf3 return \{ success: true, orderId \};
\f0\fs14 \cf2 Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 [event.payload.orderId]: \{\
...event.payload,\
status: "pending"\
\}\
\}\
\};\
\});\
return \{ updated: true \};\
\});\
// Handle queries\
orderQueryNode.on("get-order", (event) => \{\
const \{ orderId \} = event.payload;\
// Return query result directly\
return orderQueryNode.state.get(state => state.orders?.[orderId]\
|| null);\
\});\

\fs25\fsmilli12816 This pattern showcases Happen's ability to separate different concerns\
(writing vs. reading) while maintaining the causal relationships between them.\

\fs32\fsmilli16020 Observer Pattern\

\fs25\fsmilli12816 The observer pattern lets nodes observe and react to events without the\
sender needing to know about the observers, promoting loose coupling and\
modular design.\

\fs22\fsmilli11214 // Subject node that emits events\
const userNode = createNode("user-service");\
// Process user profile updates and notify observers\
userNode.on("update-user-profile", (event) => \{\
const \{ userId, profileData \} = event.payload;\
// Update the user profile\
userNode.state.set(state => \{\
const users = state.users || \{\};\
return \{\
...state,\
users: \{\
...users,\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 179 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 ...users,\
[userId]: \{\
...(users[userId] || \{\}),\
...profileData,\
updatedAt: Date.now()\
\}\
\}\
\};\
\});\
// Emit an event for observers\
userNode.broadcast(\{\
type: "user-profile-updated",\
payload: \{\
userId,\
updatedFields: Object.keys(profileData),\
timestamp: Date.now()\
\}\
\});\
return \{ success: true \};\
\});\
// Observer nodes that react to events\
const notificationNode = createNode("notification-service");\
const analyticsNode = createNode("analytics-service");\
const searchIndexNode = createNode("search-index-service");\
// Each observer reacts independently\
notificationNode.on("user-profile-updated", (event) => \{\
// Send notification about profile update\
if (event.payload.updatedFields.includes("email")) \{\
sendEmailChangeNotification(event.payload.userId);\
\}\
\});\
return \{ notified: true \};\
analyticsNode.on("user-profile-updated", (event) => \{\
// Track profile update for analytics\
recordProfileUpdateMetrics(event.payload);\
return \{ tracked: true \};\
\});\
searchIndexNode.on("user-profile-updated", (event) => \{\
// Update search index with new profile data\
refreshUserSearchIndex(event.payload.userId);\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 180 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 refreshUserSearchIndex(event.payload.userId);\
return \{ indexed: true \};\
\});\

\fs25\fsmilli12816 This pattern demonstrates Happen's natural support for decoupled, event-\
driven architectures where components can react to system events without\
direct dependencies.\

\fs32\fsmilli16020 Strategy Pattern\

\fs25\fsmilli12816 The strategy pattern allows selecting an algorithm at runtime, which Happen\
implements naturally through event handlers and dynamic routing.\

\fs22\fsmilli11214 // Create a pricing strategy node\
const pricingStrategyNode = createNode("pricing-strategy");\
// Handle pricing requests with different strategies\
pricingStrategyNode.on("calculate-price", (event) => \{\
const \{ items, strategy, customerInfo \} = event.payload;\
// Select strategy based on the event payload\
let total;\
switch(strategy) \{\
case "volume-discount":\
total = calculateVolumeDiscount(items);\
break;\
case "premium-customer":\
total = calculatePremiumPrice(items, customerInfo?.tier);\
break;\
case "regular":\
default:\
total = calculateRegularPrice(items);\
\}\
// Return pricing result\
return \{\
total,\
appliedStrategy: strategy,\
calculatedAt: Date.now()\
\};\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 181 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \});\
// Strategy implementations\
function calculateRegularPrice(items) \{\
return items.reduce((total, item) => total + item.price *\
item.quantity, 0);\
\}\
function calculateVolumeDiscount(items) \{\
let total = 0;\
for (const item of items) \{\
let price = item.price;\
if (item.quantity > 10) \{\
// 10% discount\
price = price * 0.9;\
\}\
total += price * item.quantity;\
\}\
return total;\
\}\
function calculatePremiumPrice(items, customerTier) \{\
const baseTotal = calculateRegularPrice(items);\
const discountRate = customerTier === "gold" ? 0.15 : 0.1;\
return baseTotal * (1 - discountRate);\
\}\

\fs25\fsmilli12816 This pattern shows how Happen supports dynamic behavior selection without\
requiring complex class hierarchies or inheritance.\

\fs32\fsmilli16020 Mediator Pattern\

\fs25\fsmilli12816 The mediator pattern provides centralized coordination between multiple\
components, reducing direct dependencies and simplifying complex\
workflows.\

\fs22\fsmilli11214 // Create a mediator node\
const workflowMediator = createNode("workflow-mediator");\
// Handle workflow initiation\
workflowMediator.on("start-onboarding", async (event) => \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 182 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 workflowMediator.on("start-onboarding", async (event) => \{\
const \{ userId \} = event.payload;\
// Step 1: Create user account\
const accountResult = await workflowMediator.send(accountNode, \{\
type: "create-account",\
payload: \{ userId, ...event.payload.userData \}\
\}).return();\
if (!accountResult.success) \{\
return \{\
success: false,\
stage: "account-creation",\
reason: accountResult.reason\
\};\
\}\
// Step 2: Set up permissions\
const permissionResult = await\
workflowMediator.send(permissionNode, \{\
type: "assign-default-roles",\
payload: \{\
userId,\
accountId: accountResult.accountId\
\}\
\}).return();\
if (!permissionResult.success) \{\
return \{\
success: false,\
stage: "permission-setup",\
reason: permissionResult.reason\
\};\
\}\
// Step 3: Send welcome email\
await workflowMediator.send(notificationNode, \{\
type: "send-welcome-email",\
payload: \{\
userId,\
email: event.payload.userData.email\
\}\
\});\
// Notify about completion\
workflowMediator.broadcast(\{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 183 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 type: "user-onboarded",\
payload: \{ userId, status: "completed" \}\
\});\
return \{\
success: true,\
userId,\
accountId: accountResult.accountId\
\};\
\});\

\fs25\fsmilli12816 This pattern showcases Happen's ability to orchestrate complex workflows\
while keeping individual components focused on their specific responsibilities.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 184 of 234Happen\
7/7/25, 07:52\

\f1\fs76\fsmilli38449 \cf3 Advanced\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 185 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Asynchronous Processing\

\fs25\fsmilli12816 Asynchronous processing is a cornerstone of Happen's design, allowing the\
framework to handle concurrent events efficiently while maintaining its\
commitment to radical simplicity. This document explains how Happen\
approaches asynchronous processing through multiple strategies: concurrent\
event handling, direct runtime capabilities, function-based flows, and\
streaming results.\

\fs38\fsmilli19224 Core Approach\

\fs25\fsmilli12816 In Happen, multiple events arriving at a node are processed concurrently\
without blocking each other, leveraging JavaScript's asynchronous\
capabilities while preserving event isolation. This happens as an\
implementation detail rather than an explicit API feature.\
When events arrive at a node:\
\cf5 1. \cf3 Each event gets its own independent execution context\
\cf5 2. \cf3 Events are processed concurrently using JavaScript's natural Promise\
mechanism\
\cf5 3. \cf3 One event processing never blocks another, even within the same node\
This approach ensures that slow-running event handlers don't create\
bottlenecks for unrelated events.\

\fs38\fsmilli19224 The Functional Asynchronous Model\

\fs25\fsmilli12816 Happen embraces JavaScript's native asynchronous capabilities while\
providing a clean, functional interface through the Event Continuum model:\

\fs22\fsmilli11214 // Register an asynchronous handler\
orderNode.on("process-order", async (event, context) => \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 186 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 orderNode.on("process-order", async (event, context) => \{\
// Perform asynchronous validation\
const validationResult = await validateOrderData(event.payload);\
// Store in context\
context.validation = validationResult;\
if (!validationResult.valid) \{\
return \{\
success: false,\
reason: "validation-failed",\
errors: validationResult.errors\
\};\
\}\
// Return the next function to execute\
return processPayment;\
\});\
// Asynchronous function in the flow\
async function processPayment(event, context) \{\
// Process payment asynchronously\
const paymentResult = await\
processTransaction(event.payload.payment);\
// Store in context\
context.payment = paymentResult;\
if (!paymentResult.success) \{\
return handlePaymentFailure;\
\}\
// Return next function\
return createShipment;\
\}\

\fs25\fsmilli12816 Happen's event execution engine handles the async nature transparently:\
\cf5 1. \cf3 When a function returns a Promise, Happen awaits it automatically\
\cf5 2. \cf3 Async functions are fully supported throughout the flow\
\cf5 3. \cf3 Error handling works seamlessly with async/await\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 187 of 234Happen\
7/7/25, 07:52\

\f1\fs38\fsmilli19224 \cf3 Automatic Queue Management\

\fs25\fsmilli12816 For high-volume scenarios, Happen includes internal queue management to\
prevent overwhelming the system:\

\fs22\fsmilli11214 // Internal queue management - not exposed to users\
class Node \{\
// Configuration for concurrent execution\
#concurrencySettings = \{\
maxConcurrent: 100, // Maximum concurrent executions\
queueLimit: 10000 // Maximum queued events\
\};\
#activeCount = 0; #queue = []; // Currently executing handlers\
// Queue of pending events\
// Process with queue management\
process(event) \{\
// If under concurrent limit, execute immediately\
if (this.#activeCount <\
this.#concurrencySettings.maxConcurrent) \{\
return this.executeImmediately(event);\
\}\
// Otherwise, queue the event\
return this.queueEvent(event);\
\}\
// Execute immediately\
executeImmediately(event) \{\
this.#activeCount++;\
// Start the event flow\
return this.executeFlow(event)\
.finally(() => \{\
this.#activeCount--;\
this.processNextFromQueue();\
\});\
\}\
// Queue for later execution\
queueEvent(event) \{\
// Check queue limits\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 188 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \{\
// Check queue limits\
if (this.#queue.length >= this.#concurrencySettings.queueLimit)\
return Promise.reject(new Error("Event queue limit\
exceeded"));\
\}\
// Create deferred promise\
let resolve, reject;\
const promise = new Promise((res, rej) => \{\
resolve = res;\
reject = rej;\
\});\
// Add to queue with resolvers\
this.#queue.push(\{ event, resolve, reject \});\
return promise;\
\}\
// Process next from queue\
processNextFromQueue() \{\
// If queue empty or at concurrency limit, do nothing\
if (this.#queue.length === 0 ||\
this.#activeCount >=\
this.#concurrencySettings.maxConcurrent) \{\
return;\
\}\
// Get next event from queue\
const next = this.#queue.shift();\
// Process it\
this.executeImmediately(next.event)\
.then(result => next.resolve(result))\
.catch(error => next.reject(error));\
\}\
\}\

\fs25\fsmilli12816 This queue management:\
\cf5 1. \cf3 Limits maximum concurrent event handling to prevent resource exhaustion\
\cf5 2. \cf3 Preserves ordered processing within each event type\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 189 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 3. \cf3 Provides backpressure for high-volume scenarios\
\cf5 4. \cf3 Manages memory usage by controlling queue size\

\fs38\fsmilli19224 Node Configuration\

\fs25\fsmilli12816 Happen manages concurrency through the system configuration. This\
approach keeps infrastructure concerns separated from domain logic and\
provides consistent behavior across your application.\

\fs32\fsmilli16020 System-Level Concurrency Configuration\

\fs25\fsmilli12816 Concurrency settings are defined during framework initialization:\

\fs22\fsmilli11214 // Initialization with system-wide defaults\
const happen = initializeHappen(\{\
// Core security configuration\
security: \{\
// Security settings...\
\},\
// System-wide concurrency configuration\
concurrency: \{\
// Default settings for all nodes\
default: \{\
maxConcurrent: 100, // Maximum concurrent executions\
queueLimit: 10000, // Maximum queued events\
queueStrategy: "fifo", // First-in-first-out processing\
backpressureThreshold: 0.8 // Apply backpressure at 80%\
capacity\
\},\
// Node-specific overrides based on node ID patterns\
patterns: \{\
"api-*": \{\
maxConcurrent: 200, queueLimit: 20000 // Higher concurrency for API nodes\
// Larger queue for API nodes\
\},\
"worker-*": \{\
maxConcurrent: 50, // Lower concurrency for worker\
nodes\
queueStrategy: "priority" // Priority-based queuing\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 190 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \},\
nodes\
"realtime-*": \{\
maxConcurrent: 300, // Higher concurrency for realtime\
queueLimit: 5000, // Smaller queue to avoid stale data\
backpressureThreshold: 0.6 // Earlier backpressure\
\}\
\}\
\},\
transport: \{\
// Transport settings...\
\}\
\});\
// The initialized framework provides the node creation function\
const \{ createNode \} = happen;\

\fs25\fsmilli12816 This hierarchical approach ensures consistent behavior while allowing for\
customization where needed.\

\fs38\fsmilli19224 Generator-Based Streaming\

\fs25\fsmilli12816 Building on the foundation of asynchronous processing, Happen supports\
generator-based streaming for incremental data processing.\
Instead of introducing separate API methods for streaming, Happen detects\
generator functions automatically:\

\fs22\fsmilli11214 // Register a handler that happens to be a generator function\
node.on("process-large-dataset", async function*\
processLargeDataset(event, context) \{\
const \{ dataset \} = event.payload;\
// Process in chunks\
for (let i = 0; i < dataset.length; i += 100) \{\
const chunk = dataset.slice(i, i + 100);\
const result = await processChunk(chunk);\
// Yield intermediate results\
yield \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 191 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 yield \{\
progress: Math.min(100, Math.round((i + chunk.length) /\
dataset.length * 100)),\
results: result\
\};\
\}\
// Final result\
return \{ status: "complete" \};\
\});\

\fs25\fsmilli12816 When interacting with a generator-based handler, Happen automatically\
provides an AsyncIterator interface:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 192 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Request handling of a large dataset using the flow mechanism\
clientNode.on("process-dataset", async function*\
handleDatasetProcessing(event, context) \{\
// Send the request to the processor node\
const processingEvent = \{\
type: "process-large-dataset",\
payload: \{ dataset: event.payload.dataset \}\
\};\
// Use the send method without chaining\
const processingStream = await clientNode.send(processorNode,\
processingEvent);\
// Process results incrementally using the event continuum\
for await (const update of processingStream) \{\
// Log progress\
console.log(`Progress: $\{update.progress\}%`);\
// Display intermediate results\
displayIntermediateResults(update.results);\
// Yield progress updates to the caller if needed\
yield \{\
status: "processing",\
progress: update.progress,\
resultsCount: update.results.length\
\};\
\}\
// Return final result\
return \{\
status: "complete",\
message: "Dataset processing complete"\
\};\
\});\
// To use this handler:\
const result = await userNode.send(clientNode, \{\
type: "process-dataset",\
payload: \{\
dataset: largeDataset\
\}\
\});\
// The result will be the final return value from the handler\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 193 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Generator functions also work with broadcasting, enabling publish-subscribe\
patterns for streams:\

\fs22\fsmilli11214 // Continuous system monitoring with generator\
monitorNode.on("system-metrics", async function* generateMetrics()\
\{\
while (true) \{\
const metrics = await collectSystemMetrics();\
yield metrics;\
await sleep(5000); // Update every 5 seconds\
\}\
\});\
// Start broadcasting metrics\
monitorNode.broadcast(\{ type: "system-metrics" \});\
// Subscribers receive the stream\
dashboardNode.on("system-metrics", async function\
processMetrics(metricsStream, context) \{\
// Iterate through metrics stream\
for await (const metrics of metricsStream) \{\
// Update dashboard\
updateDashboard(metrics);\
\}\
\});\

\fs38\fsmilli19224 Use Cases for Streaming\

\fs25\fsmilli12816 Generator-based streaming in Happen addresses several key use cases:\

\fs32\fsmilli16020 1. Large Dataset Processing\

\fs25\fsmilli12816 Break down large datasets into manageable chunks:\

\fs22\fsmilli11214 dataProcessorNode.on("process-batch", async function*\
processBatch(event, context) \{\
const \{ items \} = event.payload;\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 194 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 const \{ items \} = event.payload;\
// Process in chunks to avoid memory issues\
for (let i = 0; i < items.length; i += 100) \{\
const chunk = items.slice(i, i + 100);\
const results = await processChunk(chunk);\
yield \{\
progress: Math.round((i + chunk.length) / items.length *\
100),\
processedItems: chunk.length,\
results\
\};\
\}\
\});\

\fs32\fsmilli16020 2. Real-time Progress Updates\

\fs25\fsmilli12816 Provide incremental feedback for long-running operations:\

\fs22\fsmilli11214 importNode.on("import-file", async function* importFile(event,\
context) \{\
const \{ filePath \} = event.payload;\
const fileSize = await getFileSize(filePath);\
const reader = createFileReader(filePath);\
let bytesProcessed = 0;\
// Process file in chunks\
while (!reader.eof()) \{\
const chunk = await reader.readChunk(1024 * 1024); // 1MB\
chunks\
const records = parseRecords(chunk);\
await saveRecords(records);\
bytesProcessed += chunk.length;\
// Yield progress update\
yield \{\
progress: Math.round(bytesProcessed / fileSize * 100),\
recordsProcessed: records.length\
\};\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 195 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Final result\
return \{ status: "complete", totalRecords: getTotalRecords() \};\
\});\

\fs32\fsmilli16020 3. Continuous Data Streams\

\fs25\fsmilli12816 Handle data from sources that produce continuous updates:\

\fs22\fsmilli11214 sensorNode.on("monitor-sensors", async function*\
monitorSensors(event, context) \{\
const \{ sensorIds, duration \} = event.payload;\
const endTime = Date.now() + duration;\
// Connect to sensors\
const sensors = sensorIds.map(id => connectToSensor(id));\
try \{\
// Process sensor data until duration expires\
while (Date.now() < endTime) \{\
// Collect readings from all sensors\
const readings = await Promise.all(\
sensors.map(sensor => sensor.getReading())\
);\
// Process this batch of readings\
const analysis = analyzeReadings(readings);\
// Emit real-time analysis\
yield \{\
timestamp: Date.now(),\
readings,\
analysis\
\};\
// Wait before next collection\
await sleep(1000); // 1 second interval\
\}\
\} finally \{\
// Clean up resources\
sensors.forEach(sensor => sensor.disconnect());\
\}\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 196 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \});\

\fs32\fsmilli16020 4. Paginated API Results\

\fs25\fsmilli12816 Fetch and process paginated data from external APIs:\

\fs22\fsmilli11214 apiNode.on("fetch-all-records", async function*\
fetchAllRecords(event, context) \{\
const \{ endpoint, pageSize = 100 \} = event.payload;\
let page = 1;\
let hasMore = true;\
let totalRecords = 0;\
// Fetch pages until complete\
while (hasMore) \{\
// Fetch this page\
const response = await fetch(`$\{endpoint\}?\
page=$\{page\}&size=$\{pageSize\}`);\
const data = await response.json();\
// Process records\
processRecords(data.records);\
totalRecords += data.records.length;\
// Yield progress\
yield \{\
page,\
records: data.records,\
totalRecords,\
hasMore: data.hasMore\
\};\
// Update for next iteration\
hasMore = data.hasMore;\
page++;\
// Respect rate limits\
if (hasMore) \{\
await sleep(200); // Small delay between requests\
\}\
\}\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 197 of 234Happen\
7/7/25, 07:52\

\f1\fs38\fsmilli19224 \cf3 Benefits of Happen's Async Processing Model\

\fs25\fsmilli12816 The combination of concurrent event processing and generator-based\
streaming delivers several key benefits:\
\cf5 1. \cf3 Maximized Throughput: Multiple events process concurrently without\
blocking\
\cf5 2. \cf3 Resource Efficiency: Memory usage is controlled through incremental\
processing\
\cf5 3. \cf3 Responsive System: Long-running operations don't block other\
processing\
\cf5 4. \cf3 Natural Backpressure: Consumers process stream results at their own\
pace\
\cf5 5. \cf3 Minimal API Surface: Power and flexibility without additional primitives\
\cf5 6. \cf3 Clean Isolation: Each processing path maintains its own context and error\
boundaries\

\fs38\fsmilli19224 Choosing the Right Concurrency Approach\

\fs25\fsmilli12816 With multiple approaches to concurrency available in Happen, here's a quick\
guide to choosing the right one for different scenarios:\

\fs22\fsmilli11214 Approach Best For When To Use\
Functional Flows Most use cases Default approach for all\
event handling\
Async/Await Asynchronous operations When operations need to\
wait for external results\
Generator-based\
Streaming Incremental processing For progress updates and\
chunked processing\
Worker Threads CPU-intensive tasks When tasks would block\
the main thread\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 198 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 Distributed Processing Horizontal scaling When single machine\
capacity is exceeded\

\fs38\fsmilli19224 Key Takeaways\

\fs25\fsmilli12816 \cf5 1. \cf3 The Event Continuum model naturally supports asynchronous processing\
through JavaScript's native async/await\
\cf5 2. \cf3 Runtime transparency allows direct use of platform-specific concurrency\
features\
\cf5 3. \cf3 Generator-based streaming provides powerful incremental processing\
with minimal API additions\
\cf5 4. \cf3 Internal queue management ensures system stability under high load\
This multi-faceted approach delivers flexible asynchronous capabilities by\
providing multiple concurrency strategies that compose seamlessly.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 199 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Flow Balance\

\fs25\fsmilli12816 At the core of Happen's resilience capabilities is Flow Balance, a powerful yet\
invisible mechanism that leverages NATS features to monitor the health of\
your distributed system through natural message flow patterns.\
Flow Balance builds on NATS JetStream's built-in monitoring capabilities to\
provide insights into your distributed system's health:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Message Tracking: NATS JetStream tracks message delivery and\
acknowledgment\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Consumer Lag: Happens detects when consumers fall behind producers\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Delivery Failures: JetStream's acknowledgment system reveals delivery\
problems\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Partition Detection: Patterns in message flow reveal network partitions\
This NATS-powered approach gives Happen a natural way to detect issues in\
your distributed system without requiring complex configuration or special\
APIs.\

\fs38\fsmilli19224 How Flow Balance Works\

\fs25\fsmilli12816 Flow Balance operates by monitoring the natural patterns in your message\
flow through NATS:\
\cf5 1. \cf3 JetStream Consumer Monitoring: Happen leverages JetStream's\
consumer metrics to track delivery success\
\cf5 2. \cf3 Lag Detection: When consumers fall behind producers, Happen detects\
potential issues\
\cf5 3. \cf3 Event Emission: When issues are detected, Happen emits system events\
that applications can respond to\
Unlike traditional health monitoring systems that rely on external probes, Flow\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 200 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Balance uses the message flow itself as an indicator of system health.\

\fs38\fsmilli19224 Observable Patterns\

\fs25\fsmilli12816 Different types of issues create distinctive flow patterns that your handlers\
can interpret:\
\cf5 1. \cf3 Network Partitions:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Pattern: Sharp drop in delivery across node groups\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Distribution: Clear grouping pattern - nodes on one side can't reach\
nodes on the other\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Timing: Occurs suddenly and affects multiple nodes simultaneously\
\cf5 2. \cf3 Node Failures:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Pattern: Delivery failures specifically for one node\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Distribution: Concentrated around the failed node\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Timing: Occurs suddenly for the specific node\
\cf5 3. \cf3 Processing Bottlenecks:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Pattern: Gradually increasing consumer lag for a specific node\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Distribution: Usually affects a single node or service\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Timing: Develops gradually over time\
\cf5 4. \cf3 System Overload:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Pattern: Rising consumer lag across most or all nodes\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Distribution: Affects most components somewhat equally\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Timing: Often correlates with increased event volume\
By analyzing these patterns in your handlers, you can determine the specific\
type of issue occurring and implement appropriate recovery strategies.\

\fs38\fsmilli19224 Imbalance Events\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 201 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 When Flow Balance detects issues, it emits events that your application can\
listen for and respond to:\

\fs22\fsmilli11214 // Listen for node-specific imbalance events\
happen.on("node.down", (event) => \{\
const \{ nodeId, lagMetrics, pattern \} = event.payload;\
// Implement your recovery strategy\
if (lagMetrics.messagesWaiting > 1000) \{\
// Severe imbalance - potential failure\
implementNodeFailureRecovery(nodeId);\
\} else if (lagMetrics.messagesWaiting > 500) \{\
// Moderate imbalance - potential bottleneck\
applyBackpressure(nodeId);\
\} else \{\
// Minor imbalance - monitor\
logImbalance(nodeId, lagMetrics);\
\}\
\});\
// Listen for system-wide imbalance events\
happen.on("system.down", (event) => \{\
const \{ level, affectedNodes, pattern \} = event.payload;\
// Implement system-wide recovery\
if (level === "critical") \{\
// Severe system-wide issue\
enableEmergencyMode();\
\} else if (level === "warning") \{\
// Moderate system-wide issue\
throttleNonEssentialOperations();\
\}\
\});\

\fs38\fsmilli19224 Building Recovery Strategies\

\fs25\fsmilli12816 Happen provides the detection capabilities through NATS, and you can\
implement recovery strategies based on your application's needs:\

\fs22\fsmilli11214 // Listen for potential partition events\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 202 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 // Listen for potential partition events\
happen.on("node.down", (event) => \{\
const \{ nodeId, lagMetrics, affectedNodes \} = event.payload;\
// Check for partition pattern\
if (isPotentialPartition(nodeId, affectedNodes, lagMetrics)) \{\
// Implement partition recovery strategy\
enablePartitionMode(\{\
isolatedNodes: affectedNodes,\
prioritizeLocalOperations: true,\
queueRemoteOperations: true\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \});\
// Notify operations team\
alertOperations(\{\
type: "network-partition",\
affectedNodes,\
detectedAt: Date.now()\
\});\
\}\
\});\

\fs38\fsmilli19224 Benefits of Flow Balance\

\fs25\fsmilli12816 This approach provides several key advantages:\
\cf5 1. \cf3 Zero API Surface: No special methods or configuration parameters\
\cf5 2. \cf3 Zero Additional Overhead: Uses existing NATS monitoring capabilities\
\cf5 3. \cf3 Natural Detection: System issues reveal themselves through flow patterns\
\cf5 4. \cf3 Customizable Response: You control how your application responds to\
different issues\
\cf5 5. \cf3 Transport Independence: Works the same across all NATS deployment\
models\
\cf5 6. \cf3 Observable Patterns: Clear indicators of different types of system issues\
By leveraging NATS's built-in monitoring capabilities, Happen provides\
powerful system insights with minimal overhead.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 203 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Zero-Allocation Processing\

\fs38\fsmilli19224 Memory-Efficient Event Handling for Performance-\
Critical Paths\

\fs25\fsmilli12816 Happen's zero-allocation processing provides a powerful technique for\
handling high-volume events with minimal memory overhead. This advanced\
feature allows you to create processing pipelines that operate directly on\
memory buffers without creating explicit intermediate objects, significantly\
reducing garbage collection pressure in performance-critical scenarios.\
\cf5 JavaScript Reality: We use the term "zero-allocation" to describe the\
framework's guarantee of making no explicit allocations in its processing\
path. The JavaScript runtime may still perform internal allocations beyond\
our control. This feature provides a significant reduction in allocation\
overhead, not a complete elimination of all memory operations.\

\fs38\fsmilli19224 \cf3 Core Concept\

\fs25\fsmilli12816 Most JavaScript applications create thousands of objects during normal\
operation. Each object allocation consumes memory, and the JavaScript\
garbage collector must eventually reclaim that memory, which can cause\
performance hiccups. Zero-allocation processing aims to minimize these\
allocations by working directly with preallocated memory buffers.\
In Happen, zero-allocation processing provides:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Direct buffer-based event representation\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Minimal object creation during event processing\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Reduced garbage collection overhead\

\f2\fs38\fsmilli19224 \cf5 \'95\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 204 of 234Happen\
7/7/25, 07:52\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Higher sustained throughput for critical event paths\

\fs38\fsmilli19224 When to Use Zero-Allocation Processing\

\fs25\fsmilli12816 Zero-allocation processing adds complexity to your code, so it's important to\
use it selectively. Here are scenarios where it provides genuine value:\

\fs32\fsmilli16020 Particularly Valuable For:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 High-frequency event processing (thousands per second) where GC\
pauses impact throughput\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Memory-constrained JavaScript environments like IoT devices running\
Node.js, JerryScript, or Espruino\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Edge computing scenarios processing continuous streams of telemetry\
or sensor data\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Real-time applications with consistent latency requirements that GC\
pauses would disrupt\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Time-series data processing with predictable memory usage patterns\

\fs32\fsmilli16020 Less Beneficial For:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Standard business logic with moderate event volumes\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Infrequent or complex events where developer readability is more valuable\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Applications already running on high-memory environments where GC is\
not a bottleneck\
Remember that in a JavaScript environment, the runtime still handles memory\
management. Zero-allocation processing minimizes the framework's\
allocations, but doesn't eliminate all memory operations at the language level.\

\fs38\fsmilli19224 The API Surface\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 205 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Unlike many advanced features, zero-allocation processing in Happen\
requires learning just one additional method:\

\fs22\fsmilli11214 // Register a zero-allocation handler\
node.zero("event-type", (buffer, offsets) => \{\
// Work directly with buffer\
// Return value or next function as usual\
\});\

\fs25\fsmilli12816 This minimal API extension maintains Happen's commitment to simplicity\
while providing access to powerful performance optimization.\

\fs38\fsmilli19224 Working with Event Buffers\

\fs25\fsmilli12816 When your handler is invoked through the zero-allocation path, it receives:\
\cf5 1. 2. 
\fs22\fsmilli11214 \cf3 buffer 
\fs25\fsmilli12816 containing event data\

\fs22\fsmilli11214 offsets 
\fs25\fsmilli12816 are located in the buffer\
- A specialized interface to the underlying memory buffer\
- A map of offsets indicating where different event components\
Here's how you access event data:\

\fs22\fsmilli11214 node.zero("sensor-reading", (buffer, offsets) => \{\
// Get simple values\
const sensorId = buffer.getString(offsets.payload.sensorId);\
const temperature =\
buffer.getFloat64(offsets.payload.temperature);\
const timestamp = buffer.getUint64(offsets.payload.timestamp);\
// Access nested structures\
const latitude =\
buffer.getFloat64(offsets.payload.location.latitude);\
const longitude =\
buffer.getFloat64(offsets.payload.location.longitude);\
// Process data without creating objects\
const convertedTemp = (temperature * 9/5) + 32;\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 206 of 234Happen\

\f1\fs22\fsmilli11214 \cf3 const convertedTemp = (temperature * 9/5) + 32;\
// Return result directly\
return \{ processed: true, convertedValue: convertedTemp \};\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \});\

\fs25\fsmilli12816 The 
\fs22\fsmilli11214 buffer 
\fs25\fsmilli12816 object provides methods for accessing different data types:\

\fs22\fsmilli11214 Method Description\

\fs19\fsmilli9812 getInt8/16/32/64(offset) 
\fs22\fsmilli11214 Get signed integer of specified bit width\

\fs19\fsmilli9812 getUint8/16/32/64(offset) 
\fs22\fsmilli11214 Get unsigned integer of specified bit\
width\

\fs19\fsmilli9812 getFloat32/64(offset) 
\fs22\fsmilli11214 Get floating point number\

\fs19\fsmilli9812 getString(offset) 
\fs22\fsmilli11214 Get string from internal string table\

\fs19\fsmilli9812 getBoolean(offset) 
\fs22\fsmilli11214 Get boolean value\

\fs38\fsmilli19224 How It Works Under the Hood\

\fs25\fsmilli12816 Understanding the implementation can help you set realistic expectations and\
maximize the benefits:\
\cf5 1. \cf3 Pre-allocated Buffer Pool: Happen maintains a pool of preallocated\
ArrayBuffers for events, eliminating the need for per-event allocations.\
\cf5 2. \cf3 String Table: Since strings can't be stored directly in ArrayBuffers with\
variable length, Happen maintains a string table where strings are stored\
once and referenced by offset.\
\cf5 3. \cf3 Memory Layout: Each event in the buffer has a consistent memory layout\
with fixed offsets for common fields and a dynamic section for payload\
data.\
\cf5 4. \cf3 Minimal-Copy Processing: When possible, event data is processed in-\
place with minimal copying.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 207 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 5. \cf3 Buffer Reuse: After an event is processed, its buffer slot returns to the\
pool for reuse.\
\cf5 6. \cf3 Automatic Conversion: When zero-allocation handlers need to interact\
with standard handlers, Happen automatically handles the conversion at\
the boundary.\
JavaScript Engine Considerations\
It's important to understand that even with our zero-allocation approach:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 The JavaScript engine may still perform hidden allocations internally\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 JIT optimization might influence actual memory behavior\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Garbage collection can still occur, though less frequently\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Performance characteristics vary across JavaScript engines (V8,\
SpiderMonkey, JavaScriptCore)\
These realities don't diminish the value of the approach, but they do set\
proper expectations for what's achievable in a managed language\
environment.\

\fs38\fsmilli19224 The Event Continuum with Zero-Allocation\

\fs25\fsmilli12816 Zero-allocation handlers seamlessly integrate with Happen's Event Continuum\
flow control:\

\fs22\fsmilli11214 node.zero("process-batch", (buffer, offsets) => \{\
// Process first stage with zero allocations\
// Return next function to continue flow\
return secondStage;\
\});\
// Second stage can be a standard or zero-allocation function\
function secondStage(bufferOrEvent, offsetsOrContext) \{\
// Check which type we received\
if (bufferOrEvent.isBuffer) \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 208 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 if (bufferOrEvent.isBuffer) \{\
// Continue zero-allocation processing\
\} else \{\
// Handle as standard event\
\}\
// Return next function or result as usual\
return \{ completed: true \};\
\}\

\fs25\fsmilli12816 This allows you to build sophisticated processing pipelines that combine the\
performance of zero-allocation with the flexibility of standard event handling.\

\fs38\fsmilli19224 Memory Layout and Buffer Structure\

\fs25\fsmilli12816 For those who need to understand the details, here's how event data is\
structured in memory:\

\f3\fs22\fsmilli11214 \uc0\u9484 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9488 \
\uc0\u9474 
\f1  Event Header (32 bytes)
\f3 \uc0\u9474 \
\uc0\u9500 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9508 \
\uc0\u9474 
\f1  Type Reference (8 bytes)
\f3 \uc0\u9474 \
\uc0\u9500 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9508 \
\uc0\u9474 
\f1  Context Block (64 bytes)
\f3 \uc0\u9474 \
\uc0\u9500 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9508 \
\uc0\u9474 
\f1  Payload Block (variable)
\f3 \uc0\u9474 \
\uc0\u9492 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9472 \u9496 \

\f1\fs25\fsmilli12816 Each value in the payload is stored at a specific offset, with complex nested\
structures mapped to a flat offset structure. The 
\fs22\fsmilli11214 offsets 
\fs25\fsmilli12816 parameter provides\
this mapping so you don't need to calculate positions manually.\

\fs38\fsmilli19224 Performance Considerations\

\fs25\fsmilli12816 To maximize the benefits of zero-allocation processing:\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 209 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 1. \cf3 Minimize Conversions: Try to keep data in buffer form as long as\
possible. Each conversion between standard and buffer representations\
has a cost.\
\cf5 2. \cf3 Avoid Creating Objects: Creating objects inside zero handlers defeats the\
purpose. Work with primitive values where possible.\
\cf5 3. \cf3 Use Primitive Operations: Stick to arithmetic and direct buffer\
manipulation rather than object-oriented operations.\
\cf5 4. \cf3 Consider Buffer Size: Very large events may not benefit as much from\
zero-allocation.\
\cf5 5. \cf3 Measure Actual Impact: The benefits of zero-allocation processing are\
highly dependent on your specific workload, environment, and event\
characteristics. Always profile before and after implementation to ensure\
the complexity is justified by measurable improvements.\
\cf5 6. \cf3 Consider WebAssembly: For absolute performance requirements where\
JavaScript limitations are too constraining, consider WebAssembly\
modules for the most performance-critical operations.\

\fs32\fsmilli16020 Real-World Benefits\

\fs25\fsmilli12816 Despite JavaScript's limitations, we can generate significant improvements in\
specific scenarios:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 40-60% reduction in garbage collection frequency\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 More consistent performance with fewer GC-related latency spikes\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Better predictability in memory-constrained IoT deployments\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Higher sustainable throughput for sensor data processing\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Prevention of out-of-memory conditions on edge devices\
The key is applying this technique selectively where its benefits outweigh the\
added complexity.\

\fs38\fsmilli19224 Example: Processing Sensor Readings\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 210 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 Here's a complete example of using zero-allocation processing for high-\
frequency sensor data:\

\fs22\fsmilli11214 // Create a sensor data processor\
const sensorNode = createNode("sensor-processor");\
// Handle individual readings with standard processing\
sensorNode.on("sensor-reading", (event, context) => \{\
const \{ sensorId, value, timestamp \} = event.payload;\
// Process the reading\
const processed = processReading(sensorId, value, timestamp);\
// Store result\
sensorNode.state.set(state => (\{\
...state,\
readings: \{\
...state.readings,\
[sensorId]: \{\
lastValue: value,\
lastUpdated: timestamp,\
processedValue: processed\
\}\
\}\
\}));\
return \{ processed: true, value: processed \};\
\});\
// Handle batches with zero-allocation processing\
sensorNode.zero("sensor-batch", (buffer, offsets) => \{\
// Get batch metadata\
const count = buffer.getUint32(offsets.payload.count);\
const deviceId = buffer.getString(offsets.payload.deviceId);\
// Process all readings in the batch\
let totalValue = 0;\
const readingsOffset = offsets.payload.readings;\
for (let i = 0; i < count; i++) \{\
// Calculate offset for this reading in the array\
const readingOffset = readingsOffset + (i * 16); // Each\
reading is 16 bytes\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 211 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 // Get reading data directly from buffer\
const sensorId = buffer.getUint16(readingOffset);\
const value = buffer.getFloat32(readingOffset + 4);\
const timestamp = buffer.getUint64(readingOffset + 8);\
// Process without creating objects\
const processed = value * calibrationFactor(sensorId);\
totalValue += processed;\
// Update state (minimal object creation)\
updateSensorState(sensorId, value, processed, timestamp);\
\}\
// Return summary without creating intermediate objects\
return \{\
deviceId,\
processedCount: count,\
averageValue: totalValue / count\
\};\
\});\
// Utility for minimal state updates\
function updateSensorState(sensorId, value, processed, timestamp) \{\
// Use direct state operations instead of immutable patterns\
// for performance-critical code\
const readings = sensorNode.state.get().readings || \{\};\
if (!readings[sensorId]) \{\
readings[sensorId] = \{\};\
\}\
readings[sensorId].lastValue = value;\
readings[sensorId].lastUpdated = timestamp;\
readings[sensorId].processedValue = processed;\
\}\

\fs38\fsmilli19224 Conclusion\

\fs25\fsmilli12816 Zero-allocation processing provides a powerful tool for performance-critical\
paths in your Happen applications. By working directly with memory buffers\
and minimizing explicit object creation, you can achieve higher throughput\
and lower latency for high-frequency events, even within the constraints of a\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 212 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 JavaScript environment.\
This feature is most valuable in specific scenarios where reducing allocation\
pressure delivers tangible benefits:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Edge computing with high-volume data processing\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 IoT devices with limited memory\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Applications requiring predictable latency characteristics\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Time-series and sensor data processing\
Remember that this is an advanced technique that trades developer\
experience for performance. Use it selectively where the benefits outweigh\
the added complexity, and always measure the actual performance impact in\
your specific use case.\
For most application code, Happen's standard event handling strikes the right\
balance between performance and developer experience. With our unified\
approach you can apply zero-allocation processing precisely where it matters\
most while keeping the rest of your codebase clean and idiomatic.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 213 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Advanced Patterns\

\fs32\fsmilli16020 Saga Pattern for Distributed Transactions\

\fs25\fsmilli12816 The Saga pattern manages distributed transactions through a sequence of\
local operations, each with compensating actions for failure scenarios. This is\
particularly valuable for maintaining consistency across distributed\
components.\

\fs22\fsmilli11214 // Create a saga coordinator\
const orderSaga = createNode("order-saga");\
// Start saga for order processing\
orderSaga.on("process-order", async (event) => \{\
const \{ orderId \} = event.payload;\
const context = \{ orderId, steps: [] \};\
try \{\
// Step 1: Reserve inventory\
const inventoryResult = await orderSaga.send(inventoryNode, \{\
type: "reserve-inventory",\
payload: event.payload\
\}).return();\
if (!inventoryResult.success) \{\
throw new Error(`Inventory reservation failed:\
$\{inventoryResult.reason\}`);\
\}\
context.steps.push("inventory-reserved");\
// Step 2: Process payment\
const paymentResult = await orderSaga.send(paymentNode, \{\
type: "process-payment",\
payload: event.payload\
\}).return();\
if (!paymentResult.success) \{\
throw new Error(`Payment failed: $\{paymentResult.reason\}`);\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 214 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 context.steps.push("payment-processed");\
context.paymentId = paymentResult.paymentId;\
// Step 3: Create shipment\
const shipmentResult = await orderSaga.send(shipmentNode, \{\
type: "create-shipment",\
payload: \{\
orderId,\
items: event.payload.items,\
address: event.payload.shippingAddress\
\}\
\}).return();\
if (!shipmentResult.success) \{\
throw new Error(`Shipment creation failed:\
$\{shipmentResult.reason\}`);\
\}\
// Complete the saga\
orderSaga.broadcast(\{\
type: "order-processed",\
payload: \{\
orderId,\
status: "processed",\
shipmentId: shipmentResult.shipmentId\
\}\
\});\
return \{\
success: true,\
orderId,\
shipmentId: shipmentResult.shipmentId\
\};\
\} catch (error) \{\
// Execute compensating transactions in reverse order\
if (context.steps.includes("payment-processed")) \{\
await orderSaga.send(paymentNode, \{\
type: "refund-payment",\
payload: \{\
paymentId: context.paymentId\
\}\
\}).return();\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 215 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 if (context.steps.includes("inventory-reserved")) \{\
await orderSaga.send(inventoryNode, \{\
type: "release-inventory",\
payload: event.payload\
\}).return();\
\}\
// Saga failed\
orderSaga.broadcast(\{\
type: "order-processing-failed",\
payload: \{\
orderId,\
reason: error.message\
\}\
\});\
return \{\
success: false,\
reason: error.message\
\};\
\}\
\});\

\fs25\fsmilli12816 This implementation shows how Happen's event-driven model naturally\
supports complex transactional scenarios that span multiple services.\

\fs32\fsmilli16020 Retry Pattern with Exponential Backoff\

\fs25\fsmilli12816 The Retry pattern handles transient failures by automatically retrying\
operations with increasing delays between attempts.\

\fs22\fsmilli11214 // Create a service node with retry capability\
const paymentServiceNode = createNode("payment-service");\
// Process payment with retry logic\
paymentServiceNode.on("process-payment", async function\
processPayment(event, context) \{\
// Initialize retry context if not exists\
context.retryCount = context.retryCount || 0;\
context.startTime = context.startTime || Date.now();\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 216 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 try \{\
// Attempt payment processing\
const result = await chargeCustomer(event.payload);\
// Success - return result\
return \{\
success: true,\
transactionId: result.transactionId,\
amount: event.payload.amount,\
processedAt: Date.now()\
\};\
\} catch (error) \{\
// Store error in context\
context.lastError = error;\
context.retryCount++;\
// Determine if we should retry\
const maxRetries = 5;\
const maxDuration = 2 * 60 * 1000; // 2 minutes\
const timeElapsed = Date.now() - context.startTime;\
if (context.retryCount < maxRetries && timeElapsed <\
maxDuration) \{\
// Calculate exponential backoff delay\
const delay = Math.min(100 * Math.pow(2, context.retryCount),\
5000);\
// Log retry attempt\
console.log(`Retrying payment\
($\{context.retryCount\}/$\{maxRetries\}) after $\{delay\}ms delay`);\
// Wait before retrying\
await new Promise(resolve => setTimeout(resolve, delay));\
// Return self to retry\
return processPayment;\
\}\
// Too many retries or timeout exceeded\
return \{\
success: false,\
reason: "payment-failed-after-retries",\
attempts: context.retryCount,\
lastError: context.lastError.message\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 217 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 lastError: context.lastError.message\
\};\
\}\
\});\

\fs25\fsmilli12816 This pattern demonstrates Happen's function-returning mechanism to create\
sophisticated retry logic with minimal code.\

\fs32\fsmilli16020 Circuit Breaker Pattern\

\fs25\fsmilli12816 The Circuit Breaker pattern prevents cascading failures by stopping\
operations that are likely to fail.\

\fs22\fsmilli11214 // Create a node with circuit breaker capability\
const apiGatewayNode = createNode("api-gateway");\
// Circuit state storage\
const circuits = \{\
payment: \{\
state: "closed", // closed, open, half-open\
failures: 0,\
lastFailure: null,\
resetTimeout: null\
\}\
\};\
// Handler with circuit breaker logic\
apiGatewayNode.on("call-payment-service", function\
processPaymentRequest(event, context) \{\
const circuit = circuits.payment;\
// Check circuit state\
if (circuit.state === "open") \{\
// Circuit is open - fail fast\
return \{\
success: false,\
reason: "circuit-open",\
message: "Payment service is unavailable"\
\};\
\}\
// Process request with circuit awareness\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 218 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 return makePaymentServiceCall;\
\});\
// Function to make the actual service call\
async function makePaymentServiceCall(event, context) \{\
const circuit = circuits.payment;\
try \{\
// Attempt to call the payment service\
const result = await callPaymentService(event.payload);\
// Success - reset circuit if needed\
if (circuit.state === "half-open") \{\
circuit.state = "closed";\
circuit.failures = 0;\
\}\
// Return successful result\
return result;\
\} catch (error) \{\
// Update circuit on failure\
circuit.failures++;\
circuit.lastFailure = Date.now();\
// Check if we should open the circuit\
if (circuit.state === "closed" && circuit.failures >= 5) \{\
// Open the circuit\
circuit.state = "open";\
// Schedule reset to half-open\
circuit.resetTimeout = setTimeout(() => \{\
circuit.state = "half-open";\
\}, 30000); // 30 second timeout\
\}\
// Return error with circuit status\
return \{\
success: false,\
reason: "payment-service-error",\
message: error.message,\
circuitState: circuit.state\
\};\
\}\
\}\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 219 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 This pattern shows how Happen can be extended to implement sophisticated\
resilience patterns that protect systems from cascading failures.\

\fs32\fsmilli16020 Supervisor Pattern\

\fs25\fsmilli12816 The Supervisor pattern manages component lifecycles and handles failures\
through a hierarchical oversight structure.\

\fs22\fsmilli11214 // Create a supervisor node\
const supervisorNode = createNode("system-supervisor");\
// Register handler for all error events\
supervisorNode.on(type => type.endsWith(".error"), (event) => \{\
// Extract service name from event type\
const service = event.type.split('.')[0];\
// Update service state\
supervisorNode.state.set(state => \{\
const services = state.services || \{\};\
const serviceState = services[service] || \{\
errors: 0,\
lastError: 0,\
lastReset: 0,\
restarts: 0\
\};\
// Update error count\
const updatedServiceState = \{\
...serviceState,\
errors: serviceState.errors + 1,\
lastError: Date.now()\
\};\
// Return updated state\
return \{\
...state,\
services: \{\
...services,\
[service]: updatedServiceState\
\}\
\};\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 220 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \};\
\});\
// Get updated service state\
const serviceState = supervisorNode.state.get(state =>\
(state.services && state.services[service]) || \{ errors: 0,\
lastReset: 0 \}\
);\
// Check restart threshold\
if (serviceState.errors >= 5 && Date.now() -\
serviceState.lastReset < 60000) \{\
// Service is failing too frequently - trigger restart\
supervisorNode.broadcast(\{\
type: "service.restart-required",\
payload: \{\
service,\
reason: "excessive-errors",\
errorCount: serviceState.errors\
\}\
\});\
\}\
return \{ supervised: true \};\
\});\
// Handle service restart\
supervisorNode.on("service.restart-required", (event) => \{\
const \{ service \} = event.payload;\
console.log(`Restarting service: $\{service\}`);\
// Broadcast restart event\
supervisorNode.broadcast(\{\
type: "infrastructure.restart-service",\
payload: \{\
service,\
triggeredBy: "supervisor",\
reason: event.payload.reason\
\}\
\});\
// Update service state\
supervisorNode.state.set(state => \{\
const services = state.services || \{\};\
const serviceState = services[service] || \{\};\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 221 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 const serviceState = services[service] || \{\};\
return \{\
...state,\
services: \{\
...services,\
[service]: \{\
...serviceState,\
errors: 0,\
lastReset: Date.now(),\
restarts: (serviceState.restarts || 0) + 1\
\}\
\}\
\};\
\});\
return \{ action: "restart", service \};\
\});\

\fs25\fsmilli12816 This pattern demonstrates Happen's ability to implement hierarchical\
oversight and automated recovery mechanisms using its core primitives.\

\fs32\fsmilli16020 State Machine Workflow\

\fs25\fsmilli12816 The State Machine pattern models entities that transition between discrete\
states according to well-defined rules.\

\fs22\fsmilli11214 // Create a state machine node\
const orderStateMachine = createNode("order-state-machine");\
// Define allowed transitions\
const allowedTransitions = \{\
"draft": ["submitted"],\
"submitted": ["processing", "canceled"],\
"processing": ["shipped", "canceled"],\
"shipped": ["delivered"],\
"canceled": []\
\};\
// Process transition requests\
orderStateMachine.on("transition-order", (event) => \{\
const \{ orderId, toState \} = event.payload;\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 222 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 const \{ orderId, toState \} = event.payload;\
// Get current order state\
orderStateMachine.state.get(state => \{\
const order = (state.orders || \{\})[orderId];\
if (!order) \{\
return \{\
success: false,\
reason: "order-not-found"\
\};\
\}\
// Check if transition is allowed\
const currentState = order.status;\
if (!allowedTransitions[currentState]?.includes(toState)) \{\
return \{\
success: false,\
reason: "invalid-transition",\
message: `Cannot transition from $\{currentState\} to\
$\{toState\}`\
\};\
\}\
// Apply the transition\
orderStateMachine.state.set(state => \{\
const orders = state.orders || \{\};\
return \{\
...state,\
orders: \{\
...orders,\
[orderId]: \{\
...order,\
status: toState,\
transitionedAt: Date.now(),\
previousStatus: currentState\
\}\
\}\
\};\
\});\
// Broadcast state change event\
orderStateMachine.broadcast(\{\
type: "order-state-changed",\
payload: \{\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 223 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 payload: \{\
orderId,\
fromState: currentState,\
toState,\
timestamp: Date.now()\
\}\
\});\
return \{\
success: true,\
orderId,\
currentState: toState\
\};\
\});\
\});\

\fs25\fsmilli12816 This pattern shows how Happen's state management capabilities can be used\
to implement formal state machines with controlled transitions.\

\fs32\fsmilli16020 Reactive Aggregates\

\fs25\fsmilli12816 The Reactive Aggregates pattern combines event-driven reactivity with\
consistent state management for domain aggregates.\

\fs22\fsmilli11214 // Create an aggregate node\
const customerAggregate = createNode("customer-aggregate");\
// React to events and update aggregate state\
customerAggregate.on("customer-registered", (event) => \{\
const \{ customerId, email, name \} = event.payload;\
// Create new aggregate state\
customerAggregate.state.set(state => \{\
const customers = state.customers || \{\};\
return \{\
...state,\
customers: \{\
...customers,\
[customerId]: \{\
id: customerId,\
email,\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 224 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 email,\
name,\
status: "active",\
registeredAt: Date.now(),\
orders: []\
\}\
\}\
\};\
\});\
return \{ updated: true \};\
\});\
// Add order to customer aggregate\
customerAggregate.on("order-created", (event) => \{\
const \{ orderId, customerId, amount \} = event.payload;\
// Update aggregate state\
customerAggregate.state.set(state => \{\
const customers = state.customers || \{\};\
const customer = customers[customerId];\
if (!customer) \{\
return state; // Customer not found, state unchanged\
\}\
return \{\
...state,\
customers: \{\
...customers,\
[customerId]: \{\
...customer,\
orders: [\
...customer.orders,\
\{\
id: orderId,\
amount,\
createdAt: Date.now()\
\}\
],\
totalSpent: (customer.totalSpent || 0) + amount,\
lastOrderAt: Date.now()\
\}\
\}\
\};\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 225 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 \});\
// Check if customer qualifies for premium status\
const customer = customerAggregate.state.get(state =>\
(state.customers || \{\})[customerId]\
);\
if (customer && customer.orders.length >= 5 && customer.status\
!== "premium") \{\
// Upgrade to premium status\
customerAggregate.state.set(state => \{\
const customers = state.customers || \{\};\
return \{\
...state,\
customers: \{\
...customers,\
[customerId]: \{\
...customers[customerId],\
status: "premium",\
upgradedAt: Date.now()\
\}\
\}\
\};\
\});\
// Broadcast premium status event\
customerAggregate.broadcast(\{\
type: "customer-premium-status-achieved",\
payload: \{\
customerId,\
ordersCount: customer.orders.length,\
totalSpent: customer.totalSpent + amount\
\}\
\});\
\}\
\});\
return \{ updated: true \};\
// Command handler for direct interactions with the aggregate\
customerAggregate.on("update-customer-email", (event) => \{\
const \{ customerId, email \} = event.payload;\
// Validate customer exists\
const customer = customerAggregate.state.get(state =>\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 226 of 234Happen\
7/7/25, 07:52\

\f1\fs22\fsmilli11214 \cf3 const customer = customerAggregate.state.get(state =>\
(state.customers || \{\})[customerId]\
);\
if (!customer) \{\
return \{\
success: false,\
reason: "customer-not-found"\
\};\
\}\
// Update email\
customerAggregate.state.set(state => \{\
const customers = state.customers || \{\};\
return \{\
...state,\
customers: \{\
...customers,\
[customerId]: \{\
...customers[customerId],\
email,\
emailUpdatedAt: Date.now()\
\}\
\}\
\};\
\});\
// Broadcast email changed event\
customerAggregate.broadcast(\{\
type: "customer-email-changed",\
payload: \{\
customerId,\
previousEmail: customer.email,\
newEmail: email\
\}\
\});\
return \{\
success: true,\
customerId\
\};\
\});\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 227 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf3 This pattern demonstrates how Happen can combine reactive event handling\
with consistent state management in domain-driven designs.\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 228 of 234Happen\
7/7/25, 07:52\

\f1\fs76\fsmilli38449 \cf3 Open Source\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 229 of 234Happen\
7/7/25, 07:52\

\f1\fs57\fsmilli28836 \cf3 Contributing\

\fs25\fsmilli12816 Don't be shy!\

\fs48\fsmilli24030 Contributing to Happen\

\fs25\fsmilli12816 Thank you for your interest in contributing to Happen! As a framework built on\
the philosophy of radical simplicity, we value contributions that maintain this\
principle while extending the framework's capabilities.\

\fs38\fsmilli19224 Core Philosophy\

\fs25\fsmilli12816 Before contributing, please familiarize yourself with Happen's core\
philosophy:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Radical Simplicity: True power emerges from simplicity rather than\
complexity\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Pure Causality: Events form natural causal chains that define system\
behavior\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Decentralized Intelligence: Smart systems emerge from simple nodes\
making local decisions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Composable Primitives: Complex behaviors emerge from simple,\
understandable parts\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Runtime Transparency: Direct access to the underlying runtime\
environments\
Our goal is to maintain a framework with minimal primitives that compose to\
create powerful capabilities. We believe the most elegant solutions often\
emerge not from adding complexity, but from discovering the right minimal\
abstractions.\

\fs38\fsmilli19224 How to Contribute\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 230 of 234Happen\

\f1\fs38\fsmilli19224 \cf3 How to Contribute\

\f0\fs14 \cf2 7/7/25, 07:52\

\f1\fs32\fsmilli16020 \cf3 Reporting Issues\

\fs25\fsmilli12816 When reporting issues, please include:\
\cf5 1. \cf3 A clear description of the problem\
\cf5 2. \cf3 Steps to reproduce the issue\
\cf5 3. \cf3 Expected vs. actual behavior\
\cf5 4. \cf3 Version information (Happen version, runtime environment, OS)\
\cf5 5. \cf3 Minimal code example that demonstrates the issue\

\fs32\fsmilli16020 Feature Requests\

\fs25\fsmilli12816 We welcome feature requests that align with Happen's philosophy. When\
suggesting features:\
\cf5 1. \cf3 Describe the problem you're trying to solve before proposing a solution\
\cf5 2. \cf3 Explain how the feature aligns with Happen's philosophy of radical\
simplicity\
\cf5 3. \cf3 Consider whether the feature could be implemented as a composable\
extension rather than a core addition\
\cf5 4. \cf3 If possible, include examples of how the feature would be used\

\fs32\fsmilli16020 Pull Requests\

\fs25\fsmilli12816 When submitting pull requests:\
\cf5 1. \cf3 Create a branch with a descriptive name (e.g., 
\fs22\fsmilli11214 feature/event-replay 
\fs25\fsmilli12816 or\

\fs22\fsmilli11214 fix/node-discovery 
\fs25\fsmilli12816 )\
\cf5 2. \cf3 Include tests for new functionality\
\cf5 3. \cf3 Ensure all tests pass\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 231 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 4. \cf3 Update documentation to reflect changes\
\cf5 5. \cf3 Keep PRs focused on a single concern\
\cf5 6. \cf3 Follow the existing code style and patterns\

\fs38\fsmilli19224 Development Setup\

\fs25\fsmilli12816 \cf5 1. \cf3 Fork and clone the repository\

\fs22\fsmilli11214 git clone https://github.com/RobAntunes/happen.git\
cd happen\

\fs25\fsmilli12816 \cf5 2. \cf3 Install dependencies\

\fs22\fsmilli11214 npm install\

\fs25\fsmilli12816 \cf5 3. \cf3 Run tests\

\fs22\fsmilli11214 npm test\

\fs38\fsmilli19224 Coding Guidelines\

\fs32\fsmilli16020 Simplicity First\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Before adding code, ask: "Is this the simplest possible solution?"\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Prefer fewer, well-designed primitives over many specialized ones\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Follow the principle of "Do One Thing Well"\

\fs32\fsmilli16020 Event-Driven Design\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Maintain the event-driven nature of the framework\

\f2\fs38\fsmilli19224 \cf5 \'95\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 232 of 234Happen\
7/7/25, 07:52\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Ensure causality is preserved in all operations\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Keep nodes focused on single responsibilities\

\fs32\fsmilli16020 API Design\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 APIs should be intuitive and consistent with existing patterns\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Prefer composable functions over complex objects\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Maintain backward compatibility when possible\

\fs32\fsmilli16020 Testing\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Write unit tests for all new functionality\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Include integration tests for complex interactions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Test across different runtime environments when applicable\

\fs38\fsmilli19224 Documentation\

\fs25\fsmilli12816 Documentation is crucial for a framework like Happen. When adding or\
changing features:\
\cf5 1. \cf3 Update the relevant documentation files\
\cf5 2. \cf3 Include clear, concise examples\
\cf5 3. \cf3 Explain not just how to use a feature, but why and when to use it\
\cf5 4. \cf3 Ensure code examples are tested and working\

\fs38\fsmilli19224 Review Process\

\fs25\fsmilli12816 All contributions go through a review process:\
\cf5 1. \cf3 Automated checks (linting, tests)\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 233 of 234Happen\
7/7/25, 07:52\

\f1\fs25\fsmilli12816 \cf5 2. \cf3 Code review by maintainers\
\cf5 3. \cf3 Possible revisions based on feedback\
\cf5 4. \cf3 Final approval and merge\

\fs38\fsmilli19224 Community Guidelines\

\fs25\fsmilli12816 We strive to maintain a welcoming and inclusive community:\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Be respectful and considerate in all interactions\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Focus on the ideas being discussed, not the person presenting them\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Assume good intentions from other contributors\

\f2\fs38\fsmilli19224 \cf5 \'95 
\f1\fs25\fsmilli12816 \cf3 Help others learn and grow through constructive feedback\

\fs38\fsmilli19224 Recognition\

\fs25\fsmilli12816 All contributors are valued and will be recognized in our documentation and\
release notes. Significant contributors may be invited to join as maintainers.\

\fs38\fsmilli19224 Questions?\

\fs25\fsmilli12816 If you have questions about contributing, please \cf4 open an issue \cf3 "question".\
with the label\
Thank you for helping make Happen better while embracing the philosophy of\
simplicity!\

\f0\fs14 \cf2 https://open-2c.gitbook.com/~space/q8vrBtTE7RgMKLs2m89I/~gitbook/pdf?limit=100&back=false\
Page 234 of 234}